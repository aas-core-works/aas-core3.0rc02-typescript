/**
 * Test JSON de/serialization of interfaces.
 */

// This code has been automatically generated by:
// testgen/aas_core_3_0_rc2_typescript_testgen/generate_test_for_jsonization_of_interfaces.py
// Do NOT edit or append.

import * as AasJsonization from "../src/jsonization";
import * as TestCommon from "./common";
import * as TestCommonJsonization from "./commonJsonization";

test("IHasSemantics round-trip " + "starting from RelationshipElement OK", () => {
  const instance = TestCommonJsonization.loadMinimalRelationshipElement();

  const jsonable = AasJsonization.toJsonable(instance);

  const anotherInstanceOrError = AasJsonization.hasSemanticsFromJsonable(jsonable);
  expect(anotherInstanceOrError.error).toBeNull();
  const anotherInstance = anotherInstanceOrError.mustValue();

  const anotherJsonable = AasJsonization.toJsonable(anotherInstance);

  const inequalityError = TestCommon.checkJsonablesEqual(jsonable, anotherJsonable);
  if (inequalityError !== null) {
    throw new Error(
      "The minimal example of IHasSemantics " +
        "as an instance of RelationshipElement serialized " +
        "to JSON, then de-serialized and serialized again does not match " +
        `the first JSON: ${inequalityError.path}: ${inequalityError.message}`
    );
  }
});

test(
  "IHasSemantics round-trip " + "starting from AnnotatedRelationshipElement OK",
  () => {
    const instance = TestCommonJsonization.loadMinimalAnnotatedRelationshipElement();

    const jsonable = AasJsonization.toJsonable(instance);

    const anotherInstanceOrError = AasJsonization.hasSemanticsFromJsonable(jsonable);
    expect(anotherInstanceOrError.error).toBeNull();
    const anotherInstance = anotherInstanceOrError.mustValue();

    const anotherJsonable = AasJsonization.toJsonable(anotherInstance);

    const inequalityError = TestCommon.checkJsonablesEqual(jsonable, anotherJsonable);
    if (inequalityError !== null) {
      throw new Error(
        "The minimal example of IHasSemantics " +
          "as an instance of AnnotatedRelationshipElement serialized " +
          "to JSON, then de-serialized and serialized again does not match " +
          `the first JSON: ${inequalityError.path}: ${inequalityError.message}`
      );
    }
  }
);

test("IHasSemantics round-trip " + "starting from BasicEventElement OK", () => {
  const instance = TestCommonJsonization.loadMinimalBasicEventElement();

  const jsonable = AasJsonization.toJsonable(instance);

  const anotherInstanceOrError = AasJsonization.hasSemanticsFromJsonable(jsonable);
  expect(anotherInstanceOrError.error).toBeNull();
  const anotherInstance = anotherInstanceOrError.mustValue();

  const anotherJsonable = AasJsonization.toJsonable(anotherInstance);

  const inequalityError = TestCommon.checkJsonablesEqual(jsonable, anotherJsonable);
  if (inequalityError !== null) {
    throw new Error(
      "The minimal example of IHasSemantics " +
        "as an instance of BasicEventElement serialized " +
        "to JSON, then de-serialized and serialized again does not match " +
        `the first JSON: ${inequalityError.path}: ${inequalityError.message}`
    );
  }
});

test("IHasSemantics round-trip " + "starting from Blob OK", () => {
  const instance = TestCommonJsonization.loadMinimalBlob();

  const jsonable = AasJsonization.toJsonable(instance);

  const anotherInstanceOrError = AasJsonization.hasSemanticsFromJsonable(jsonable);
  expect(anotherInstanceOrError.error).toBeNull();
  const anotherInstance = anotherInstanceOrError.mustValue();

  const anotherJsonable = AasJsonization.toJsonable(anotherInstance);

  const inequalityError = TestCommon.checkJsonablesEqual(jsonable, anotherJsonable);
  if (inequalityError !== null) {
    throw new Error(
      "The minimal example of IHasSemantics " +
        "as an instance of Blob serialized " +
        "to JSON, then de-serialized and serialized again does not match " +
        `the first JSON: ${inequalityError.path}: ${inequalityError.message}`
    );
  }
});

test("IHasSemantics round-trip " + "starting from Capability OK", () => {
  const instance = TestCommonJsonization.loadMinimalCapability();

  const jsonable = AasJsonization.toJsonable(instance);

  const anotherInstanceOrError = AasJsonization.hasSemanticsFromJsonable(jsonable);
  expect(anotherInstanceOrError.error).toBeNull();
  const anotherInstance = anotherInstanceOrError.mustValue();

  const anotherJsonable = AasJsonization.toJsonable(anotherInstance);

  const inequalityError = TestCommon.checkJsonablesEqual(jsonable, anotherJsonable);
  if (inequalityError !== null) {
    throw new Error(
      "The minimal example of IHasSemantics " +
        "as an instance of Capability serialized " +
        "to JSON, then de-serialized and serialized again does not match " +
        `the first JSON: ${inequalityError.path}: ${inequalityError.message}`
    );
  }
});

test("IHasSemantics round-trip " + "starting from Entity OK", () => {
  const instance = TestCommonJsonization.loadMinimalEntity();

  const jsonable = AasJsonization.toJsonable(instance);

  const anotherInstanceOrError = AasJsonization.hasSemanticsFromJsonable(jsonable);
  expect(anotherInstanceOrError.error).toBeNull();
  const anotherInstance = anotherInstanceOrError.mustValue();

  const anotherJsonable = AasJsonization.toJsonable(anotherInstance);

  const inequalityError = TestCommon.checkJsonablesEqual(jsonable, anotherJsonable);
  if (inequalityError !== null) {
    throw new Error(
      "The minimal example of IHasSemantics " +
        "as an instance of Entity serialized " +
        "to JSON, then de-serialized and serialized again does not match " +
        `the first JSON: ${inequalityError.path}: ${inequalityError.message}`
    );
  }
});

test("IHasSemantics round-trip " + "starting from File OK", () => {
  const instance = TestCommonJsonization.loadMinimalFile();

  const jsonable = AasJsonization.toJsonable(instance);

  const anotherInstanceOrError = AasJsonization.hasSemanticsFromJsonable(jsonable);
  expect(anotherInstanceOrError.error).toBeNull();
  const anotherInstance = anotherInstanceOrError.mustValue();

  const anotherJsonable = AasJsonization.toJsonable(anotherInstance);

  const inequalityError = TestCommon.checkJsonablesEqual(jsonable, anotherJsonable);
  if (inequalityError !== null) {
    throw new Error(
      "The minimal example of IHasSemantics " +
        "as an instance of File serialized " +
        "to JSON, then de-serialized and serialized again does not match " +
        `the first JSON: ${inequalityError.path}: ${inequalityError.message}`
    );
  }
});

test("IHasSemantics round-trip " + "starting from MultiLanguageProperty OK", () => {
  const instance = TestCommonJsonization.loadMinimalMultiLanguageProperty();

  const jsonable = AasJsonization.toJsonable(instance);

  const anotherInstanceOrError = AasJsonization.hasSemanticsFromJsonable(jsonable);
  expect(anotherInstanceOrError.error).toBeNull();
  const anotherInstance = anotherInstanceOrError.mustValue();

  const anotherJsonable = AasJsonization.toJsonable(anotherInstance);

  const inequalityError = TestCommon.checkJsonablesEqual(jsonable, anotherJsonable);
  if (inequalityError !== null) {
    throw new Error(
      "The minimal example of IHasSemantics " +
        "as an instance of MultiLanguageProperty serialized " +
        "to JSON, then de-serialized and serialized again does not match " +
        `the first JSON: ${inequalityError.path}: ${inequalityError.message}`
    );
  }
});

test("IHasSemantics round-trip " + "starting from Operation OK", () => {
  const instance = TestCommonJsonization.loadMinimalOperation();

  const jsonable = AasJsonization.toJsonable(instance);

  const anotherInstanceOrError = AasJsonization.hasSemanticsFromJsonable(jsonable);
  expect(anotherInstanceOrError.error).toBeNull();
  const anotherInstance = anotherInstanceOrError.mustValue();

  const anotherJsonable = AasJsonization.toJsonable(anotherInstance);

  const inequalityError = TestCommon.checkJsonablesEqual(jsonable, anotherJsonable);
  if (inequalityError !== null) {
    throw new Error(
      "The minimal example of IHasSemantics " +
        "as an instance of Operation serialized " +
        "to JSON, then de-serialized and serialized again does not match " +
        `the first JSON: ${inequalityError.path}: ${inequalityError.message}`
    );
  }
});

test("IHasSemantics round-trip " + "starting from Property OK", () => {
  const instance = TestCommonJsonization.loadMinimalProperty();

  const jsonable = AasJsonization.toJsonable(instance);

  const anotherInstanceOrError = AasJsonization.hasSemanticsFromJsonable(jsonable);
  expect(anotherInstanceOrError.error).toBeNull();
  const anotherInstance = anotherInstanceOrError.mustValue();

  const anotherJsonable = AasJsonization.toJsonable(anotherInstance);

  const inequalityError = TestCommon.checkJsonablesEqual(jsonable, anotherJsonable);
  if (inequalityError !== null) {
    throw new Error(
      "The minimal example of IHasSemantics " +
        "as an instance of Property serialized " +
        "to JSON, then de-serialized and serialized again does not match " +
        `the first JSON: ${inequalityError.path}: ${inequalityError.message}`
    );
  }
});

test("IHasSemantics round-trip " + "starting from Range OK", () => {
  const instance = TestCommonJsonization.loadMinimalRange();

  const jsonable = AasJsonization.toJsonable(instance);

  const anotherInstanceOrError = AasJsonization.hasSemanticsFromJsonable(jsonable);
  expect(anotherInstanceOrError.error).toBeNull();
  const anotherInstance = anotherInstanceOrError.mustValue();

  const anotherJsonable = AasJsonization.toJsonable(anotherInstance);

  const inequalityError = TestCommon.checkJsonablesEqual(jsonable, anotherJsonable);
  if (inequalityError !== null) {
    throw new Error(
      "The minimal example of IHasSemantics " +
        "as an instance of Range serialized " +
        "to JSON, then de-serialized and serialized again does not match " +
        `the first JSON: ${inequalityError.path}: ${inequalityError.message}`
    );
  }
});

test("IHasSemantics round-trip " + "starting from ReferenceElement OK", () => {
  const instance = TestCommonJsonization.loadMinimalReferenceElement();

  const jsonable = AasJsonization.toJsonable(instance);

  const anotherInstanceOrError = AasJsonization.hasSemanticsFromJsonable(jsonable);
  expect(anotherInstanceOrError.error).toBeNull();
  const anotherInstance = anotherInstanceOrError.mustValue();

  const anotherJsonable = AasJsonization.toJsonable(anotherInstance);

  const inequalityError = TestCommon.checkJsonablesEqual(jsonable, anotherJsonable);
  if (inequalityError !== null) {
    throw new Error(
      "The minimal example of IHasSemantics " +
        "as an instance of ReferenceElement serialized " +
        "to JSON, then de-serialized and serialized again does not match " +
        `the first JSON: ${inequalityError.path}: ${inequalityError.message}`
    );
  }
});

test("IHasSemantics round-trip " + "starting from Submodel OK", () => {
  const instance = TestCommonJsonization.loadMinimalSubmodel();

  const jsonable = AasJsonization.toJsonable(instance);

  const anotherInstanceOrError = AasJsonization.hasSemanticsFromJsonable(jsonable);
  expect(anotherInstanceOrError.error).toBeNull();
  const anotherInstance = anotherInstanceOrError.mustValue();

  const anotherJsonable = AasJsonization.toJsonable(anotherInstance);

  const inequalityError = TestCommon.checkJsonablesEqual(jsonable, anotherJsonable);
  if (inequalityError !== null) {
    throw new Error(
      "The minimal example of IHasSemantics " +
        "as an instance of Submodel serialized " +
        "to JSON, then de-serialized and serialized again does not match " +
        `the first JSON: ${inequalityError.path}: ${inequalityError.message}`
    );
  }
});

test("IHasSemantics round-trip " + "starting from SubmodelElementCollection OK", () => {
  const instance = TestCommonJsonization.loadMinimalSubmodelElementCollection();

  const jsonable = AasJsonization.toJsonable(instance);

  const anotherInstanceOrError = AasJsonization.hasSemanticsFromJsonable(jsonable);
  expect(anotherInstanceOrError.error).toBeNull();
  const anotherInstance = anotherInstanceOrError.mustValue();

  const anotherJsonable = AasJsonization.toJsonable(anotherInstance);

  const inequalityError = TestCommon.checkJsonablesEqual(jsonable, anotherJsonable);
  if (inequalityError !== null) {
    throw new Error(
      "The minimal example of IHasSemantics " +
        "as an instance of SubmodelElementCollection serialized " +
        "to JSON, then de-serialized and serialized again does not match " +
        `the first JSON: ${inequalityError.path}: ${inequalityError.message}`
    );
  }
});

test("IHasSemantics round-trip " + "starting from SubmodelElementList OK", () => {
  const instance = TestCommonJsonization.loadMinimalSubmodelElementList();

  const jsonable = AasJsonization.toJsonable(instance);

  const anotherInstanceOrError = AasJsonization.hasSemanticsFromJsonable(jsonable);
  expect(anotherInstanceOrError.error).toBeNull();
  const anotherInstance = anotherInstanceOrError.mustValue();

  const anotherJsonable = AasJsonization.toJsonable(anotherInstance);

  const inequalityError = TestCommon.checkJsonablesEqual(jsonable, anotherJsonable);
  if (inequalityError !== null) {
    throw new Error(
      "The minimal example of IHasSemantics " +
        "as an instance of SubmodelElementList serialized " +
        "to JSON, then de-serialized and serialized again does not match " +
        `the first JSON: ${inequalityError.path}: ${inequalityError.message}`
    );
  }
});

test("IHasSemantics deserialization fail", () => {
  const jsonable = "This is not a IHasSemantics.";

  const instanceOrError = AasJsonization.hasSemanticsFromJsonable(jsonable);
  expect(instanceOrError.error.message).toStrictEqual(
    "Expected a JSON object, but got: string"
  );
});

test("IHasExtensions round-trip " + "starting from RelationshipElement OK", () => {
  const instance = TestCommonJsonization.loadMinimalRelationshipElement();

  const jsonable = AasJsonization.toJsonable(instance);

  const anotherInstanceOrError = AasJsonization.hasExtensionsFromJsonable(jsonable);
  expect(anotherInstanceOrError.error).toBeNull();
  const anotherInstance = anotherInstanceOrError.mustValue();

  const anotherJsonable = AasJsonization.toJsonable(anotherInstance);

  const inequalityError = TestCommon.checkJsonablesEqual(jsonable, anotherJsonable);
  if (inequalityError !== null) {
    throw new Error(
      "The minimal example of IHasExtensions " +
        "as an instance of RelationshipElement serialized " +
        "to JSON, then de-serialized and serialized again does not match " +
        `the first JSON: ${inequalityError.path}: ${inequalityError.message}`
    );
  }
});

test(
  "IHasExtensions round-trip " + "starting from AnnotatedRelationshipElement OK",
  () => {
    const instance = TestCommonJsonization.loadMinimalAnnotatedRelationshipElement();

    const jsonable = AasJsonization.toJsonable(instance);

    const anotherInstanceOrError = AasJsonization.hasExtensionsFromJsonable(jsonable);
    expect(anotherInstanceOrError.error).toBeNull();
    const anotherInstance = anotherInstanceOrError.mustValue();

    const anotherJsonable = AasJsonization.toJsonable(anotherInstance);

    const inequalityError = TestCommon.checkJsonablesEqual(jsonable, anotherJsonable);
    if (inequalityError !== null) {
      throw new Error(
        "The minimal example of IHasExtensions " +
          "as an instance of AnnotatedRelationshipElement serialized " +
          "to JSON, then de-serialized and serialized again does not match " +
          `the first JSON: ${inequalityError.path}: ${inequalityError.message}`
      );
    }
  }
);

test("IHasExtensions round-trip " + "starting from AssetAdministrationShell OK", () => {
  const instance = TestCommonJsonization.loadMinimalAssetAdministrationShell();

  const jsonable = AasJsonization.toJsonable(instance);

  const anotherInstanceOrError = AasJsonization.hasExtensionsFromJsonable(jsonable);
  expect(anotherInstanceOrError.error).toBeNull();
  const anotherInstance = anotherInstanceOrError.mustValue();

  const anotherJsonable = AasJsonization.toJsonable(anotherInstance);

  const inequalityError = TestCommon.checkJsonablesEqual(jsonable, anotherJsonable);
  if (inequalityError !== null) {
    throw new Error(
      "The minimal example of IHasExtensions " +
        "as an instance of AssetAdministrationShell serialized " +
        "to JSON, then de-serialized and serialized again does not match " +
        `the first JSON: ${inequalityError.path}: ${inequalityError.message}`
    );
  }
});

test("IHasExtensions round-trip " + "starting from BasicEventElement OK", () => {
  const instance = TestCommonJsonization.loadMinimalBasicEventElement();

  const jsonable = AasJsonization.toJsonable(instance);

  const anotherInstanceOrError = AasJsonization.hasExtensionsFromJsonable(jsonable);
  expect(anotherInstanceOrError.error).toBeNull();
  const anotherInstance = anotherInstanceOrError.mustValue();

  const anotherJsonable = AasJsonization.toJsonable(anotherInstance);

  const inequalityError = TestCommon.checkJsonablesEqual(jsonable, anotherJsonable);
  if (inequalityError !== null) {
    throw new Error(
      "The minimal example of IHasExtensions " +
        "as an instance of BasicEventElement serialized " +
        "to JSON, then de-serialized and serialized again does not match " +
        `the first JSON: ${inequalityError.path}: ${inequalityError.message}`
    );
  }
});

test("IHasExtensions round-trip " + "starting from Blob OK", () => {
  const instance = TestCommonJsonization.loadMinimalBlob();

  const jsonable = AasJsonization.toJsonable(instance);

  const anotherInstanceOrError = AasJsonization.hasExtensionsFromJsonable(jsonable);
  expect(anotherInstanceOrError.error).toBeNull();
  const anotherInstance = anotherInstanceOrError.mustValue();

  const anotherJsonable = AasJsonization.toJsonable(anotherInstance);

  const inequalityError = TestCommon.checkJsonablesEqual(jsonable, anotherJsonable);
  if (inequalityError !== null) {
    throw new Error(
      "The minimal example of IHasExtensions " +
        "as an instance of Blob serialized " +
        "to JSON, then de-serialized and serialized again does not match " +
        `the first JSON: ${inequalityError.path}: ${inequalityError.message}`
    );
  }
});

test("IHasExtensions round-trip " + "starting from Capability OK", () => {
  const instance = TestCommonJsonization.loadMinimalCapability();

  const jsonable = AasJsonization.toJsonable(instance);

  const anotherInstanceOrError = AasJsonization.hasExtensionsFromJsonable(jsonable);
  expect(anotherInstanceOrError.error).toBeNull();
  const anotherInstance = anotherInstanceOrError.mustValue();

  const anotherJsonable = AasJsonization.toJsonable(anotherInstance);

  const inequalityError = TestCommon.checkJsonablesEqual(jsonable, anotherJsonable);
  if (inequalityError !== null) {
    throw new Error(
      "The minimal example of IHasExtensions " +
        "as an instance of Capability serialized " +
        "to JSON, then de-serialized and serialized again does not match " +
        `the first JSON: ${inequalityError.path}: ${inequalityError.message}`
    );
  }
});

test("IHasExtensions round-trip " + "starting from ConceptDescription OK", () => {
  const instance = TestCommonJsonization.loadMinimalConceptDescription();

  const jsonable = AasJsonization.toJsonable(instance);

  const anotherInstanceOrError = AasJsonization.hasExtensionsFromJsonable(jsonable);
  expect(anotherInstanceOrError.error).toBeNull();
  const anotherInstance = anotherInstanceOrError.mustValue();

  const anotherJsonable = AasJsonization.toJsonable(anotherInstance);

  const inequalityError = TestCommon.checkJsonablesEqual(jsonable, anotherJsonable);
  if (inequalityError !== null) {
    throw new Error(
      "The minimal example of IHasExtensions " +
        "as an instance of ConceptDescription serialized " +
        "to JSON, then de-serialized and serialized again does not match " +
        `the first JSON: ${inequalityError.path}: ${inequalityError.message}`
    );
  }
});

test("IHasExtensions round-trip " + "starting from Entity OK", () => {
  const instance = TestCommonJsonization.loadMinimalEntity();

  const jsonable = AasJsonization.toJsonable(instance);

  const anotherInstanceOrError = AasJsonization.hasExtensionsFromJsonable(jsonable);
  expect(anotherInstanceOrError.error).toBeNull();
  const anotherInstance = anotherInstanceOrError.mustValue();

  const anotherJsonable = AasJsonization.toJsonable(anotherInstance);

  const inequalityError = TestCommon.checkJsonablesEqual(jsonable, anotherJsonable);
  if (inequalityError !== null) {
    throw new Error(
      "The minimal example of IHasExtensions " +
        "as an instance of Entity serialized " +
        "to JSON, then de-serialized and serialized again does not match " +
        `the first JSON: ${inequalityError.path}: ${inequalityError.message}`
    );
  }
});

test("IHasExtensions round-trip " + "starting from File OK", () => {
  const instance = TestCommonJsonization.loadMinimalFile();

  const jsonable = AasJsonization.toJsonable(instance);

  const anotherInstanceOrError = AasJsonization.hasExtensionsFromJsonable(jsonable);
  expect(anotherInstanceOrError.error).toBeNull();
  const anotherInstance = anotherInstanceOrError.mustValue();

  const anotherJsonable = AasJsonization.toJsonable(anotherInstance);

  const inequalityError = TestCommon.checkJsonablesEqual(jsonable, anotherJsonable);
  if (inequalityError !== null) {
    throw new Error(
      "The minimal example of IHasExtensions " +
        "as an instance of File serialized " +
        "to JSON, then de-serialized and serialized again does not match " +
        `the first JSON: ${inequalityError.path}: ${inequalityError.message}`
    );
  }
});

test("IHasExtensions round-trip " + "starting from MultiLanguageProperty OK", () => {
  const instance = TestCommonJsonization.loadMinimalMultiLanguageProperty();

  const jsonable = AasJsonization.toJsonable(instance);

  const anotherInstanceOrError = AasJsonization.hasExtensionsFromJsonable(jsonable);
  expect(anotherInstanceOrError.error).toBeNull();
  const anotherInstance = anotherInstanceOrError.mustValue();

  const anotherJsonable = AasJsonization.toJsonable(anotherInstance);

  const inequalityError = TestCommon.checkJsonablesEqual(jsonable, anotherJsonable);
  if (inequalityError !== null) {
    throw new Error(
      "The minimal example of IHasExtensions " +
        "as an instance of MultiLanguageProperty serialized " +
        "to JSON, then de-serialized and serialized again does not match " +
        `the first JSON: ${inequalityError.path}: ${inequalityError.message}`
    );
  }
});

test("IHasExtensions round-trip " + "starting from Operation OK", () => {
  const instance = TestCommonJsonization.loadMinimalOperation();

  const jsonable = AasJsonization.toJsonable(instance);

  const anotherInstanceOrError = AasJsonization.hasExtensionsFromJsonable(jsonable);
  expect(anotherInstanceOrError.error).toBeNull();
  const anotherInstance = anotherInstanceOrError.mustValue();

  const anotherJsonable = AasJsonization.toJsonable(anotherInstance);

  const inequalityError = TestCommon.checkJsonablesEqual(jsonable, anotherJsonable);
  if (inequalityError !== null) {
    throw new Error(
      "The minimal example of IHasExtensions " +
        "as an instance of Operation serialized " +
        "to JSON, then de-serialized and serialized again does not match " +
        `the first JSON: ${inequalityError.path}: ${inequalityError.message}`
    );
  }
});

test("IHasExtensions round-trip " + "starting from Property OK", () => {
  const instance = TestCommonJsonization.loadMinimalProperty();

  const jsonable = AasJsonization.toJsonable(instance);

  const anotherInstanceOrError = AasJsonization.hasExtensionsFromJsonable(jsonable);
  expect(anotherInstanceOrError.error).toBeNull();
  const anotherInstance = anotherInstanceOrError.mustValue();

  const anotherJsonable = AasJsonization.toJsonable(anotherInstance);

  const inequalityError = TestCommon.checkJsonablesEqual(jsonable, anotherJsonable);
  if (inequalityError !== null) {
    throw new Error(
      "The minimal example of IHasExtensions " +
        "as an instance of Property serialized " +
        "to JSON, then de-serialized and serialized again does not match " +
        `the first JSON: ${inequalityError.path}: ${inequalityError.message}`
    );
  }
});

test("IHasExtensions round-trip " + "starting from Range OK", () => {
  const instance = TestCommonJsonization.loadMinimalRange();

  const jsonable = AasJsonization.toJsonable(instance);

  const anotherInstanceOrError = AasJsonization.hasExtensionsFromJsonable(jsonable);
  expect(anotherInstanceOrError.error).toBeNull();
  const anotherInstance = anotherInstanceOrError.mustValue();

  const anotherJsonable = AasJsonization.toJsonable(anotherInstance);

  const inequalityError = TestCommon.checkJsonablesEqual(jsonable, anotherJsonable);
  if (inequalityError !== null) {
    throw new Error(
      "The minimal example of IHasExtensions " +
        "as an instance of Range serialized " +
        "to JSON, then de-serialized and serialized again does not match " +
        `the first JSON: ${inequalityError.path}: ${inequalityError.message}`
    );
  }
});

test("IHasExtensions round-trip " + "starting from ReferenceElement OK", () => {
  const instance = TestCommonJsonization.loadMinimalReferenceElement();

  const jsonable = AasJsonization.toJsonable(instance);

  const anotherInstanceOrError = AasJsonization.hasExtensionsFromJsonable(jsonable);
  expect(anotherInstanceOrError.error).toBeNull();
  const anotherInstance = anotherInstanceOrError.mustValue();

  const anotherJsonable = AasJsonization.toJsonable(anotherInstance);

  const inequalityError = TestCommon.checkJsonablesEqual(jsonable, anotherJsonable);
  if (inequalityError !== null) {
    throw new Error(
      "The minimal example of IHasExtensions " +
        "as an instance of ReferenceElement serialized " +
        "to JSON, then de-serialized and serialized again does not match " +
        `the first JSON: ${inequalityError.path}: ${inequalityError.message}`
    );
  }
});

test("IHasExtensions round-trip " + "starting from Submodel OK", () => {
  const instance = TestCommonJsonization.loadMinimalSubmodel();

  const jsonable = AasJsonization.toJsonable(instance);

  const anotherInstanceOrError = AasJsonization.hasExtensionsFromJsonable(jsonable);
  expect(anotherInstanceOrError.error).toBeNull();
  const anotherInstance = anotherInstanceOrError.mustValue();

  const anotherJsonable = AasJsonization.toJsonable(anotherInstance);

  const inequalityError = TestCommon.checkJsonablesEqual(jsonable, anotherJsonable);
  if (inequalityError !== null) {
    throw new Error(
      "The minimal example of IHasExtensions " +
        "as an instance of Submodel serialized " +
        "to JSON, then de-serialized and serialized again does not match " +
        `the first JSON: ${inequalityError.path}: ${inequalityError.message}`
    );
  }
});

test(
  "IHasExtensions round-trip " + "starting from SubmodelElementCollection OK",
  () => {
    const instance = TestCommonJsonization.loadMinimalSubmodelElementCollection();

    const jsonable = AasJsonization.toJsonable(instance);

    const anotherInstanceOrError = AasJsonization.hasExtensionsFromJsonable(jsonable);
    expect(anotherInstanceOrError.error).toBeNull();
    const anotherInstance = anotherInstanceOrError.mustValue();

    const anotherJsonable = AasJsonization.toJsonable(anotherInstance);

    const inequalityError = TestCommon.checkJsonablesEqual(jsonable, anotherJsonable);
    if (inequalityError !== null) {
      throw new Error(
        "The minimal example of IHasExtensions " +
          "as an instance of SubmodelElementCollection serialized " +
          "to JSON, then de-serialized and serialized again does not match " +
          `the first JSON: ${inequalityError.path}: ${inequalityError.message}`
      );
    }
  }
);

test("IHasExtensions round-trip " + "starting from SubmodelElementList OK", () => {
  const instance = TestCommonJsonization.loadMinimalSubmodelElementList();

  const jsonable = AasJsonization.toJsonable(instance);

  const anotherInstanceOrError = AasJsonization.hasExtensionsFromJsonable(jsonable);
  expect(anotherInstanceOrError.error).toBeNull();
  const anotherInstance = anotherInstanceOrError.mustValue();

  const anotherJsonable = AasJsonization.toJsonable(anotherInstance);

  const inequalityError = TestCommon.checkJsonablesEqual(jsonable, anotherJsonable);
  if (inequalityError !== null) {
    throw new Error(
      "The minimal example of IHasExtensions " +
        "as an instance of SubmodelElementList serialized " +
        "to JSON, then de-serialized and serialized again does not match " +
        `the first JSON: ${inequalityError.path}: ${inequalityError.message}`
    );
  }
});

test("IHasExtensions deserialization fail", () => {
  const jsonable = "This is not a IHasExtensions.";

  const instanceOrError = AasJsonization.hasExtensionsFromJsonable(jsonable);
  expect(instanceOrError.error.message).toStrictEqual(
    "Expected a JSON object, but got: string"
  );
});

test("IReferable round-trip " + "starting from RelationshipElement OK", () => {
  const instance = TestCommonJsonization.loadMinimalRelationshipElement();

  const jsonable = AasJsonization.toJsonable(instance);

  const anotherInstanceOrError = AasJsonization.referableFromJsonable(jsonable);
  expect(anotherInstanceOrError.error).toBeNull();
  const anotherInstance = anotherInstanceOrError.mustValue();

  const anotherJsonable = AasJsonization.toJsonable(anotherInstance);

  const inequalityError = TestCommon.checkJsonablesEqual(jsonable, anotherJsonable);
  if (inequalityError !== null) {
    throw new Error(
      "The minimal example of IReferable " +
        "as an instance of RelationshipElement serialized " +
        "to JSON, then de-serialized and serialized again does not match " +
        `the first JSON: ${inequalityError.path}: ${inequalityError.message}`
    );
  }
});

test("IReferable round-trip " + "starting from AnnotatedRelationshipElement OK", () => {
  const instance = TestCommonJsonization.loadMinimalAnnotatedRelationshipElement();

  const jsonable = AasJsonization.toJsonable(instance);

  const anotherInstanceOrError = AasJsonization.referableFromJsonable(jsonable);
  expect(anotherInstanceOrError.error).toBeNull();
  const anotherInstance = anotherInstanceOrError.mustValue();

  const anotherJsonable = AasJsonization.toJsonable(anotherInstance);

  const inequalityError = TestCommon.checkJsonablesEqual(jsonable, anotherJsonable);
  if (inequalityError !== null) {
    throw new Error(
      "The minimal example of IReferable " +
        "as an instance of AnnotatedRelationshipElement serialized " +
        "to JSON, then de-serialized and serialized again does not match " +
        `the first JSON: ${inequalityError.path}: ${inequalityError.message}`
    );
  }
});

test("IReferable round-trip " + "starting from AssetAdministrationShell OK", () => {
  const instance = TestCommonJsonization.loadMinimalAssetAdministrationShell();

  const jsonable = AasJsonization.toJsonable(instance);

  const anotherInstanceOrError = AasJsonization.referableFromJsonable(jsonable);
  expect(anotherInstanceOrError.error).toBeNull();
  const anotherInstance = anotherInstanceOrError.mustValue();

  const anotherJsonable = AasJsonization.toJsonable(anotherInstance);

  const inequalityError = TestCommon.checkJsonablesEqual(jsonable, anotherJsonable);
  if (inequalityError !== null) {
    throw new Error(
      "The minimal example of IReferable " +
        "as an instance of AssetAdministrationShell serialized " +
        "to JSON, then de-serialized and serialized again does not match " +
        `the first JSON: ${inequalityError.path}: ${inequalityError.message}`
    );
  }
});

test("IReferable round-trip " + "starting from BasicEventElement OK", () => {
  const instance = TestCommonJsonization.loadMinimalBasicEventElement();

  const jsonable = AasJsonization.toJsonable(instance);

  const anotherInstanceOrError = AasJsonization.referableFromJsonable(jsonable);
  expect(anotherInstanceOrError.error).toBeNull();
  const anotherInstance = anotherInstanceOrError.mustValue();

  const anotherJsonable = AasJsonization.toJsonable(anotherInstance);

  const inequalityError = TestCommon.checkJsonablesEqual(jsonable, anotherJsonable);
  if (inequalityError !== null) {
    throw new Error(
      "The minimal example of IReferable " +
        "as an instance of BasicEventElement serialized " +
        "to JSON, then de-serialized and serialized again does not match " +
        `the first JSON: ${inequalityError.path}: ${inequalityError.message}`
    );
  }
});

test("IReferable round-trip " + "starting from Blob OK", () => {
  const instance = TestCommonJsonization.loadMinimalBlob();

  const jsonable = AasJsonization.toJsonable(instance);

  const anotherInstanceOrError = AasJsonization.referableFromJsonable(jsonable);
  expect(anotherInstanceOrError.error).toBeNull();
  const anotherInstance = anotherInstanceOrError.mustValue();

  const anotherJsonable = AasJsonization.toJsonable(anotherInstance);

  const inequalityError = TestCommon.checkJsonablesEqual(jsonable, anotherJsonable);
  if (inequalityError !== null) {
    throw new Error(
      "The minimal example of IReferable " +
        "as an instance of Blob serialized " +
        "to JSON, then de-serialized and serialized again does not match " +
        `the first JSON: ${inequalityError.path}: ${inequalityError.message}`
    );
  }
});

test("IReferable round-trip " + "starting from Capability OK", () => {
  const instance = TestCommonJsonization.loadMinimalCapability();

  const jsonable = AasJsonization.toJsonable(instance);

  const anotherInstanceOrError = AasJsonization.referableFromJsonable(jsonable);
  expect(anotherInstanceOrError.error).toBeNull();
  const anotherInstance = anotherInstanceOrError.mustValue();

  const anotherJsonable = AasJsonization.toJsonable(anotherInstance);

  const inequalityError = TestCommon.checkJsonablesEqual(jsonable, anotherJsonable);
  if (inequalityError !== null) {
    throw new Error(
      "The minimal example of IReferable " +
        "as an instance of Capability serialized " +
        "to JSON, then de-serialized and serialized again does not match " +
        `the first JSON: ${inequalityError.path}: ${inequalityError.message}`
    );
  }
});

test("IReferable round-trip " + "starting from ConceptDescription OK", () => {
  const instance = TestCommonJsonization.loadMinimalConceptDescription();

  const jsonable = AasJsonization.toJsonable(instance);

  const anotherInstanceOrError = AasJsonization.referableFromJsonable(jsonable);
  expect(anotherInstanceOrError.error).toBeNull();
  const anotherInstance = anotherInstanceOrError.mustValue();

  const anotherJsonable = AasJsonization.toJsonable(anotherInstance);

  const inequalityError = TestCommon.checkJsonablesEqual(jsonable, anotherJsonable);
  if (inequalityError !== null) {
    throw new Error(
      "The minimal example of IReferable " +
        "as an instance of ConceptDescription serialized " +
        "to JSON, then de-serialized and serialized again does not match " +
        `the first JSON: ${inequalityError.path}: ${inequalityError.message}`
    );
  }
});

test("IReferable round-trip " + "starting from Entity OK", () => {
  const instance = TestCommonJsonization.loadMinimalEntity();

  const jsonable = AasJsonization.toJsonable(instance);

  const anotherInstanceOrError = AasJsonization.referableFromJsonable(jsonable);
  expect(anotherInstanceOrError.error).toBeNull();
  const anotherInstance = anotherInstanceOrError.mustValue();

  const anotherJsonable = AasJsonization.toJsonable(anotherInstance);

  const inequalityError = TestCommon.checkJsonablesEqual(jsonable, anotherJsonable);
  if (inequalityError !== null) {
    throw new Error(
      "The minimal example of IReferable " +
        "as an instance of Entity serialized " +
        "to JSON, then de-serialized and serialized again does not match " +
        `the first JSON: ${inequalityError.path}: ${inequalityError.message}`
    );
  }
});

test("IReferable round-trip " + "starting from File OK", () => {
  const instance = TestCommonJsonization.loadMinimalFile();

  const jsonable = AasJsonization.toJsonable(instance);

  const anotherInstanceOrError = AasJsonization.referableFromJsonable(jsonable);
  expect(anotherInstanceOrError.error).toBeNull();
  const anotherInstance = anotherInstanceOrError.mustValue();

  const anotherJsonable = AasJsonization.toJsonable(anotherInstance);

  const inequalityError = TestCommon.checkJsonablesEqual(jsonable, anotherJsonable);
  if (inequalityError !== null) {
    throw new Error(
      "The minimal example of IReferable " +
        "as an instance of File serialized " +
        "to JSON, then de-serialized and serialized again does not match " +
        `the first JSON: ${inequalityError.path}: ${inequalityError.message}`
    );
  }
});

test("IReferable round-trip " + "starting from MultiLanguageProperty OK", () => {
  const instance = TestCommonJsonization.loadMinimalMultiLanguageProperty();

  const jsonable = AasJsonization.toJsonable(instance);

  const anotherInstanceOrError = AasJsonization.referableFromJsonable(jsonable);
  expect(anotherInstanceOrError.error).toBeNull();
  const anotherInstance = anotherInstanceOrError.mustValue();

  const anotherJsonable = AasJsonization.toJsonable(anotherInstance);

  const inequalityError = TestCommon.checkJsonablesEqual(jsonable, anotherJsonable);
  if (inequalityError !== null) {
    throw new Error(
      "The minimal example of IReferable " +
        "as an instance of MultiLanguageProperty serialized " +
        "to JSON, then de-serialized and serialized again does not match " +
        `the first JSON: ${inequalityError.path}: ${inequalityError.message}`
    );
  }
});

test("IReferable round-trip " + "starting from Operation OK", () => {
  const instance = TestCommonJsonization.loadMinimalOperation();

  const jsonable = AasJsonization.toJsonable(instance);

  const anotherInstanceOrError = AasJsonization.referableFromJsonable(jsonable);
  expect(anotherInstanceOrError.error).toBeNull();
  const anotherInstance = anotherInstanceOrError.mustValue();

  const anotherJsonable = AasJsonization.toJsonable(anotherInstance);

  const inequalityError = TestCommon.checkJsonablesEqual(jsonable, anotherJsonable);
  if (inequalityError !== null) {
    throw new Error(
      "The minimal example of IReferable " +
        "as an instance of Operation serialized " +
        "to JSON, then de-serialized and serialized again does not match " +
        `the first JSON: ${inequalityError.path}: ${inequalityError.message}`
    );
  }
});

test("IReferable round-trip " + "starting from Property OK", () => {
  const instance = TestCommonJsonization.loadMinimalProperty();

  const jsonable = AasJsonization.toJsonable(instance);

  const anotherInstanceOrError = AasJsonization.referableFromJsonable(jsonable);
  expect(anotherInstanceOrError.error).toBeNull();
  const anotherInstance = anotherInstanceOrError.mustValue();

  const anotherJsonable = AasJsonization.toJsonable(anotherInstance);

  const inequalityError = TestCommon.checkJsonablesEqual(jsonable, anotherJsonable);
  if (inequalityError !== null) {
    throw new Error(
      "The minimal example of IReferable " +
        "as an instance of Property serialized " +
        "to JSON, then de-serialized and serialized again does not match " +
        `the first JSON: ${inequalityError.path}: ${inequalityError.message}`
    );
  }
});

test("IReferable round-trip " + "starting from Range OK", () => {
  const instance = TestCommonJsonization.loadMinimalRange();

  const jsonable = AasJsonization.toJsonable(instance);

  const anotherInstanceOrError = AasJsonization.referableFromJsonable(jsonable);
  expect(anotherInstanceOrError.error).toBeNull();
  const anotherInstance = anotherInstanceOrError.mustValue();

  const anotherJsonable = AasJsonization.toJsonable(anotherInstance);

  const inequalityError = TestCommon.checkJsonablesEqual(jsonable, anotherJsonable);
  if (inequalityError !== null) {
    throw new Error(
      "The minimal example of IReferable " +
        "as an instance of Range serialized " +
        "to JSON, then de-serialized and serialized again does not match " +
        `the first JSON: ${inequalityError.path}: ${inequalityError.message}`
    );
  }
});

test("IReferable round-trip " + "starting from ReferenceElement OK", () => {
  const instance = TestCommonJsonization.loadMinimalReferenceElement();

  const jsonable = AasJsonization.toJsonable(instance);

  const anotherInstanceOrError = AasJsonization.referableFromJsonable(jsonable);
  expect(anotherInstanceOrError.error).toBeNull();
  const anotherInstance = anotherInstanceOrError.mustValue();

  const anotherJsonable = AasJsonization.toJsonable(anotherInstance);

  const inequalityError = TestCommon.checkJsonablesEqual(jsonable, anotherJsonable);
  if (inequalityError !== null) {
    throw new Error(
      "The minimal example of IReferable " +
        "as an instance of ReferenceElement serialized " +
        "to JSON, then de-serialized and serialized again does not match " +
        `the first JSON: ${inequalityError.path}: ${inequalityError.message}`
    );
  }
});

test("IReferable round-trip " + "starting from Submodel OK", () => {
  const instance = TestCommonJsonization.loadMinimalSubmodel();

  const jsonable = AasJsonization.toJsonable(instance);

  const anotherInstanceOrError = AasJsonization.referableFromJsonable(jsonable);
  expect(anotherInstanceOrError.error).toBeNull();
  const anotherInstance = anotherInstanceOrError.mustValue();

  const anotherJsonable = AasJsonization.toJsonable(anotherInstance);

  const inequalityError = TestCommon.checkJsonablesEqual(jsonable, anotherJsonable);
  if (inequalityError !== null) {
    throw new Error(
      "The minimal example of IReferable " +
        "as an instance of Submodel serialized " +
        "to JSON, then de-serialized and serialized again does not match " +
        `the first JSON: ${inequalityError.path}: ${inequalityError.message}`
    );
  }
});

test("IReferable round-trip " + "starting from SubmodelElementCollection OK", () => {
  const instance = TestCommonJsonization.loadMinimalSubmodelElementCollection();

  const jsonable = AasJsonization.toJsonable(instance);

  const anotherInstanceOrError = AasJsonization.referableFromJsonable(jsonable);
  expect(anotherInstanceOrError.error).toBeNull();
  const anotherInstance = anotherInstanceOrError.mustValue();

  const anotherJsonable = AasJsonization.toJsonable(anotherInstance);

  const inequalityError = TestCommon.checkJsonablesEqual(jsonable, anotherJsonable);
  if (inequalityError !== null) {
    throw new Error(
      "The minimal example of IReferable " +
        "as an instance of SubmodelElementCollection serialized " +
        "to JSON, then de-serialized and serialized again does not match " +
        `the first JSON: ${inequalityError.path}: ${inequalityError.message}`
    );
  }
});

test("IReferable round-trip " + "starting from SubmodelElementList OK", () => {
  const instance = TestCommonJsonization.loadMinimalSubmodelElementList();

  const jsonable = AasJsonization.toJsonable(instance);

  const anotherInstanceOrError = AasJsonization.referableFromJsonable(jsonable);
  expect(anotherInstanceOrError.error).toBeNull();
  const anotherInstance = anotherInstanceOrError.mustValue();

  const anotherJsonable = AasJsonization.toJsonable(anotherInstance);

  const inequalityError = TestCommon.checkJsonablesEqual(jsonable, anotherJsonable);
  if (inequalityError !== null) {
    throw new Error(
      "The minimal example of IReferable " +
        "as an instance of SubmodelElementList serialized " +
        "to JSON, then de-serialized and serialized again does not match " +
        `the first JSON: ${inequalityError.path}: ${inequalityError.message}`
    );
  }
});

test("IReferable deserialization fail", () => {
  const jsonable = "This is not a IReferable.";

  const instanceOrError = AasJsonization.referableFromJsonable(jsonable);
  expect(instanceOrError.error.message).toStrictEqual(
    "Expected a JSON object, but got: string"
  );
});

test("IIdentifiable round-trip " + "starting from AssetAdministrationShell OK", () => {
  const instance = TestCommonJsonization.loadMinimalAssetAdministrationShell();

  const jsonable = AasJsonization.toJsonable(instance);

  const anotherInstanceOrError = AasJsonization.identifiableFromJsonable(jsonable);
  expect(anotherInstanceOrError.error).toBeNull();
  const anotherInstance = anotherInstanceOrError.mustValue();

  const anotherJsonable = AasJsonization.toJsonable(anotherInstance);

  const inequalityError = TestCommon.checkJsonablesEqual(jsonable, anotherJsonable);
  if (inequalityError !== null) {
    throw new Error(
      "The minimal example of IIdentifiable " +
        "as an instance of AssetAdministrationShell serialized " +
        "to JSON, then de-serialized and serialized again does not match " +
        `the first JSON: ${inequalityError.path}: ${inequalityError.message}`
    );
  }
});

test("IIdentifiable round-trip " + "starting from ConceptDescription OK", () => {
  const instance = TestCommonJsonization.loadMinimalConceptDescription();

  const jsonable = AasJsonization.toJsonable(instance);

  const anotherInstanceOrError = AasJsonization.identifiableFromJsonable(jsonable);
  expect(anotherInstanceOrError.error).toBeNull();
  const anotherInstance = anotherInstanceOrError.mustValue();

  const anotherJsonable = AasJsonization.toJsonable(anotherInstance);

  const inequalityError = TestCommon.checkJsonablesEqual(jsonable, anotherJsonable);
  if (inequalityError !== null) {
    throw new Error(
      "The minimal example of IIdentifiable " +
        "as an instance of ConceptDescription serialized " +
        "to JSON, then de-serialized and serialized again does not match " +
        `the first JSON: ${inequalityError.path}: ${inequalityError.message}`
    );
  }
});

test("IIdentifiable round-trip " + "starting from Submodel OK", () => {
  const instance = TestCommonJsonization.loadMinimalSubmodel();

  const jsonable = AasJsonization.toJsonable(instance);

  const anotherInstanceOrError = AasJsonization.identifiableFromJsonable(jsonable);
  expect(anotherInstanceOrError.error).toBeNull();
  const anotherInstance = anotherInstanceOrError.mustValue();

  const anotherJsonable = AasJsonization.toJsonable(anotherInstance);

  const inequalityError = TestCommon.checkJsonablesEqual(jsonable, anotherJsonable);
  if (inequalityError !== null) {
    throw new Error(
      "The minimal example of IIdentifiable " +
        "as an instance of Submodel serialized " +
        "to JSON, then de-serialized and serialized again does not match " +
        `the first JSON: ${inequalityError.path}: ${inequalityError.message}`
    );
  }
});

test("IIdentifiable deserialization fail", () => {
  const jsonable = "This is not a IIdentifiable.";

  const instanceOrError = AasJsonization.identifiableFromJsonable(jsonable);
  expect(instanceOrError.error.message).toStrictEqual(
    "Expected a JSON object, but got: string"
  );
});

test("IHasKind round-trip " + "starting from RelationshipElement OK", () => {
  const instance = TestCommonJsonization.loadMinimalRelationshipElement();

  const jsonable = AasJsonization.toJsonable(instance);

  const anotherInstanceOrError = AasJsonization.hasKindFromJsonable(jsonable);
  expect(anotherInstanceOrError.error).toBeNull();
  const anotherInstance = anotherInstanceOrError.mustValue();

  const anotherJsonable = AasJsonization.toJsonable(anotherInstance);

  const inequalityError = TestCommon.checkJsonablesEqual(jsonable, anotherJsonable);
  if (inequalityError !== null) {
    throw new Error(
      "The minimal example of IHasKind " +
        "as an instance of RelationshipElement serialized " +
        "to JSON, then de-serialized and serialized again does not match " +
        `the first JSON: ${inequalityError.path}: ${inequalityError.message}`
    );
  }
});

test("IHasKind round-trip " + "starting from AnnotatedRelationshipElement OK", () => {
  const instance = TestCommonJsonization.loadMinimalAnnotatedRelationshipElement();

  const jsonable = AasJsonization.toJsonable(instance);

  const anotherInstanceOrError = AasJsonization.hasKindFromJsonable(jsonable);
  expect(anotherInstanceOrError.error).toBeNull();
  const anotherInstance = anotherInstanceOrError.mustValue();

  const anotherJsonable = AasJsonization.toJsonable(anotherInstance);

  const inequalityError = TestCommon.checkJsonablesEqual(jsonable, anotherJsonable);
  if (inequalityError !== null) {
    throw new Error(
      "The minimal example of IHasKind " +
        "as an instance of AnnotatedRelationshipElement serialized " +
        "to JSON, then de-serialized and serialized again does not match " +
        `the first JSON: ${inequalityError.path}: ${inequalityError.message}`
    );
  }
});

test("IHasKind round-trip " + "starting from BasicEventElement OK", () => {
  const instance = TestCommonJsonization.loadMinimalBasicEventElement();

  const jsonable = AasJsonization.toJsonable(instance);

  const anotherInstanceOrError = AasJsonization.hasKindFromJsonable(jsonable);
  expect(anotherInstanceOrError.error).toBeNull();
  const anotherInstance = anotherInstanceOrError.mustValue();

  const anotherJsonable = AasJsonization.toJsonable(anotherInstance);

  const inequalityError = TestCommon.checkJsonablesEqual(jsonable, anotherJsonable);
  if (inequalityError !== null) {
    throw new Error(
      "The minimal example of IHasKind " +
        "as an instance of BasicEventElement serialized " +
        "to JSON, then de-serialized and serialized again does not match " +
        `the first JSON: ${inequalityError.path}: ${inequalityError.message}`
    );
  }
});

test("IHasKind round-trip " + "starting from Blob OK", () => {
  const instance = TestCommonJsonization.loadMinimalBlob();

  const jsonable = AasJsonization.toJsonable(instance);

  const anotherInstanceOrError = AasJsonization.hasKindFromJsonable(jsonable);
  expect(anotherInstanceOrError.error).toBeNull();
  const anotherInstance = anotherInstanceOrError.mustValue();

  const anotherJsonable = AasJsonization.toJsonable(anotherInstance);

  const inequalityError = TestCommon.checkJsonablesEqual(jsonable, anotherJsonable);
  if (inequalityError !== null) {
    throw new Error(
      "The minimal example of IHasKind " +
        "as an instance of Blob serialized " +
        "to JSON, then de-serialized and serialized again does not match " +
        `the first JSON: ${inequalityError.path}: ${inequalityError.message}`
    );
  }
});

test("IHasKind round-trip " + "starting from Capability OK", () => {
  const instance = TestCommonJsonization.loadMinimalCapability();

  const jsonable = AasJsonization.toJsonable(instance);

  const anotherInstanceOrError = AasJsonization.hasKindFromJsonable(jsonable);
  expect(anotherInstanceOrError.error).toBeNull();
  const anotherInstance = anotherInstanceOrError.mustValue();

  const anotherJsonable = AasJsonization.toJsonable(anotherInstance);

  const inequalityError = TestCommon.checkJsonablesEqual(jsonable, anotherJsonable);
  if (inequalityError !== null) {
    throw new Error(
      "The minimal example of IHasKind " +
        "as an instance of Capability serialized " +
        "to JSON, then de-serialized and serialized again does not match " +
        `the first JSON: ${inequalityError.path}: ${inequalityError.message}`
    );
  }
});

test("IHasKind round-trip " + "starting from Entity OK", () => {
  const instance = TestCommonJsonization.loadMinimalEntity();

  const jsonable = AasJsonization.toJsonable(instance);

  const anotherInstanceOrError = AasJsonization.hasKindFromJsonable(jsonable);
  expect(anotherInstanceOrError.error).toBeNull();
  const anotherInstance = anotherInstanceOrError.mustValue();

  const anotherJsonable = AasJsonization.toJsonable(anotherInstance);

  const inequalityError = TestCommon.checkJsonablesEqual(jsonable, anotherJsonable);
  if (inequalityError !== null) {
    throw new Error(
      "The minimal example of IHasKind " +
        "as an instance of Entity serialized " +
        "to JSON, then de-serialized and serialized again does not match " +
        `the first JSON: ${inequalityError.path}: ${inequalityError.message}`
    );
  }
});

test("IHasKind round-trip " + "starting from File OK", () => {
  const instance = TestCommonJsonization.loadMinimalFile();

  const jsonable = AasJsonization.toJsonable(instance);

  const anotherInstanceOrError = AasJsonization.hasKindFromJsonable(jsonable);
  expect(anotherInstanceOrError.error).toBeNull();
  const anotherInstance = anotherInstanceOrError.mustValue();

  const anotherJsonable = AasJsonization.toJsonable(anotherInstance);

  const inequalityError = TestCommon.checkJsonablesEqual(jsonable, anotherJsonable);
  if (inequalityError !== null) {
    throw new Error(
      "The minimal example of IHasKind " +
        "as an instance of File serialized " +
        "to JSON, then de-serialized and serialized again does not match " +
        `the first JSON: ${inequalityError.path}: ${inequalityError.message}`
    );
  }
});

test("IHasKind round-trip " + "starting from MultiLanguageProperty OK", () => {
  const instance = TestCommonJsonization.loadMinimalMultiLanguageProperty();

  const jsonable = AasJsonization.toJsonable(instance);

  const anotherInstanceOrError = AasJsonization.hasKindFromJsonable(jsonable);
  expect(anotherInstanceOrError.error).toBeNull();
  const anotherInstance = anotherInstanceOrError.mustValue();

  const anotherJsonable = AasJsonization.toJsonable(anotherInstance);

  const inequalityError = TestCommon.checkJsonablesEqual(jsonable, anotherJsonable);
  if (inequalityError !== null) {
    throw new Error(
      "The minimal example of IHasKind " +
        "as an instance of MultiLanguageProperty serialized " +
        "to JSON, then de-serialized and serialized again does not match " +
        `the first JSON: ${inequalityError.path}: ${inequalityError.message}`
    );
  }
});

test("IHasKind round-trip " + "starting from Operation OK", () => {
  const instance = TestCommonJsonization.loadMinimalOperation();

  const jsonable = AasJsonization.toJsonable(instance);

  const anotherInstanceOrError = AasJsonization.hasKindFromJsonable(jsonable);
  expect(anotherInstanceOrError.error).toBeNull();
  const anotherInstance = anotherInstanceOrError.mustValue();

  const anotherJsonable = AasJsonization.toJsonable(anotherInstance);

  const inequalityError = TestCommon.checkJsonablesEqual(jsonable, anotherJsonable);
  if (inequalityError !== null) {
    throw new Error(
      "The minimal example of IHasKind " +
        "as an instance of Operation serialized " +
        "to JSON, then de-serialized and serialized again does not match " +
        `the first JSON: ${inequalityError.path}: ${inequalityError.message}`
    );
  }
});

test("IHasKind round-trip " + "starting from Property OK", () => {
  const instance = TestCommonJsonization.loadMinimalProperty();

  const jsonable = AasJsonization.toJsonable(instance);

  const anotherInstanceOrError = AasJsonization.hasKindFromJsonable(jsonable);
  expect(anotherInstanceOrError.error).toBeNull();
  const anotherInstance = anotherInstanceOrError.mustValue();

  const anotherJsonable = AasJsonization.toJsonable(anotherInstance);

  const inequalityError = TestCommon.checkJsonablesEqual(jsonable, anotherJsonable);
  if (inequalityError !== null) {
    throw new Error(
      "The minimal example of IHasKind " +
        "as an instance of Property serialized " +
        "to JSON, then de-serialized and serialized again does not match " +
        `the first JSON: ${inequalityError.path}: ${inequalityError.message}`
    );
  }
});

test("IHasKind round-trip " + "starting from Range OK", () => {
  const instance = TestCommonJsonization.loadMinimalRange();

  const jsonable = AasJsonization.toJsonable(instance);

  const anotherInstanceOrError = AasJsonization.hasKindFromJsonable(jsonable);
  expect(anotherInstanceOrError.error).toBeNull();
  const anotherInstance = anotherInstanceOrError.mustValue();

  const anotherJsonable = AasJsonization.toJsonable(anotherInstance);

  const inequalityError = TestCommon.checkJsonablesEqual(jsonable, anotherJsonable);
  if (inequalityError !== null) {
    throw new Error(
      "The minimal example of IHasKind " +
        "as an instance of Range serialized " +
        "to JSON, then de-serialized and serialized again does not match " +
        `the first JSON: ${inequalityError.path}: ${inequalityError.message}`
    );
  }
});

test("IHasKind round-trip " + "starting from ReferenceElement OK", () => {
  const instance = TestCommonJsonization.loadMinimalReferenceElement();

  const jsonable = AasJsonization.toJsonable(instance);

  const anotherInstanceOrError = AasJsonization.hasKindFromJsonable(jsonable);
  expect(anotherInstanceOrError.error).toBeNull();
  const anotherInstance = anotherInstanceOrError.mustValue();

  const anotherJsonable = AasJsonization.toJsonable(anotherInstance);

  const inequalityError = TestCommon.checkJsonablesEqual(jsonable, anotherJsonable);
  if (inequalityError !== null) {
    throw new Error(
      "The minimal example of IHasKind " +
        "as an instance of ReferenceElement serialized " +
        "to JSON, then de-serialized and serialized again does not match " +
        `the first JSON: ${inequalityError.path}: ${inequalityError.message}`
    );
  }
});

test("IHasKind round-trip " + "starting from Submodel OK", () => {
  const instance = TestCommonJsonization.loadMinimalSubmodel();

  const jsonable = AasJsonization.toJsonable(instance);

  const anotherInstanceOrError = AasJsonization.hasKindFromJsonable(jsonable);
  expect(anotherInstanceOrError.error).toBeNull();
  const anotherInstance = anotherInstanceOrError.mustValue();

  const anotherJsonable = AasJsonization.toJsonable(anotherInstance);

  const inequalityError = TestCommon.checkJsonablesEqual(jsonable, anotherJsonable);
  if (inequalityError !== null) {
    throw new Error(
      "The minimal example of IHasKind " +
        "as an instance of Submodel serialized " +
        "to JSON, then de-serialized and serialized again does not match " +
        `the first JSON: ${inequalityError.path}: ${inequalityError.message}`
    );
  }
});

test("IHasKind round-trip " + "starting from SubmodelElementCollection OK", () => {
  const instance = TestCommonJsonization.loadMinimalSubmodelElementCollection();

  const jsonable = AasJsonization.toJsonable(instance);

  const anotherInstanceOrError = AasJsonization.hasKindFromJsonable(jsonable);
  expect(anotherInstanceOrError.error).toBeNull();
  const anotherInstance = anotherInstanceOrError.mustValue();

  const anotherJsonable = AasJsonization.toJsonable(anotherInstance);

  const inequalityError = TestCommon.checkJsonablesEqual(jsonable, anotherJsonable);
  if (inequalityError !== null) {
    throw new Error(
      "The minimal example of IHasKind " +
        "as an instance of SubmodelElementCollection serialized " +
        "to JSON, then de-serialized and serialized again does not match " +
        `the first JSON: ${inequalityError.path}: ${inequalityError.message}`
    );
  }
});

test("IHasKind round-trip " + "starting from SubmodelElementList OK", () => {
  const instance = TestCommonJsonization.loadMinimalSubmodelElementList();

  const jsonable = AasJsonization.toJsonable(instance);

  const anotherInstanceOrError = AasJsonization.hasKindFromJsonable(jsonable);
  expect(anotherInstanceOrError.error).toBeNull();
  const anotherInstance = anotherInstanceOrError.mustValue();

  const anotherJsonable = AasJsonization.toJsonable(anotherInstance);

  const inequalityError = TestCommon.checkJsonablesEqual(jsonable, anotherJsonable);
  if (inequalityError !== null) {
    throw new Error(
      "The minimal example of IHasKind " +
        "as an instance of SubmodelElementList serialized " +
        "to JSON, then de-serialized and serialized again does not match " +
        `the first JSON: ${inequalityError.path}: ${inequalityError.message}`
    );
  }
});

test("IHasKind deserialization fail", () => {
  const jsonable = "This is not a IHasKind.";

  const instanceOrError = AasJsonization.hasKindFromJsonable(jsonable);
  expect(instanceOrError.error.message).toStrictEqual(
    "Expected a JSON object, but got: string"
  );
});

test(
  "IHasDataSpecification round-trip " + "starting from RelationshipElement OK",
  () => {
    const instance = TestCommonJsonization.loadMinimalRelationshipElement();

    const jsonable = AasJsonization.toJsonable(instance);

    const anotherInstanceOrError =
      AasJsonization.hasDataSpecificationFromJsonable(jsonable);
    expect(anotherInstanceOrError.error).toBeNull();
    const anotherInstance = anotherInstanceOrError.mustValue();

    const anotherJsonable = AasJsonization.toJsonable(anotherInstance);

    const inequalityError = TestCommon.checkJsonablesEqual(jsonable, anotherJsonable);
    if (inequalityError !== null) {
      throw new Error(
        "The minimal example of IHasDataSpecification " +
          "as an instance of RelationshipElement serialized " +
          "to JSON, then de-serialized and serialized again does not match " +
          `the first JSON: ${inequalityError.path}: ${inequalityError.message}`
      );
    }
  }
);

test(
  "IHasDataSpecification round-trip " + "starting from AnnotatedRelationshipElement OK",
  () => {
    const instance = TestCommonJsonization.loadMinimalAnnotatedRelationshipElement();

    const jsonable = AasJsonization.toJsonable(instance);

    const anotherInstanceOrError =
      AasJsonization.hasDataSpecificationFromJsonable(jsonable);
    expect(anotherInstanceOrError.error).toBeNull();
    const anotherInstance = anotherInstanceOrError.mustValue();

    const anotherJsonable = AasJsonization.toJsonable(anotherInstance);

    const inequalityError = TestCommon.checkJsonablesEqual(jsonable, anotherJsonable);
    if (inequalityError !== null) {
      throw new Error(
        "The minimal example of IHasDataSpecification " +
          "as an instance of AnnotatedRelationshipElement serialized " +
          "to JSON, then de-serialized and serialized again does not match " +
          `the first JSON: ${inequalityError.path}: ${inequalityError.message}`
      );
    }
  }
);

test(
  "IHasDataSpecification round-trip " + "starting from AssetAdministrationShell OK",
  () => {
    const instance = TestCommonJsonization.loadMinimalAssetAdministrationShell();

    const jsonable = AasJsonization.toJsonable(instance);

    const anotherInstanceOrError =
      AasJsonization.hasDataSpecificationFromJsonable(jsonable);
    expect(anotherInstanceOrError.error).toBeNull();
    const anotherInstance = anotherInstanceOrError.mustValue();

    const anotherJsonable = AasJsonization.toJsonable(anotherInstance);

    const inequalityError = TestCommon.checkJsonablesEqual(jsonable, anotherJsonable);
    if (inequalityError !== null) {
      throw new Error(
        "The minimal example of IHasDataSpecification " +
          "as an instance of AssetAdministrationShell serialized " +
          "to JSON, then de-serialized and serialized again does not match " +
          `the first JSON: ${inequalityError.path}: ${inequalityError.message}`
      );
    }
  }
);

test("IHasDataSpecification round-trip " + "starting from BasicEventElement OK", () => {
  const instance = TestCommonJsonization.loadMinimalBasicEventElement();

  const jsonable = AasJsonization.toJsonable(instance);

  const anotherInstanceOrError =
    AasJsonization.hasDataSpecificationFromJsonable(jsonable);
  expect(anotherInstanceOrError.error).toBeNull();
  const anotherInstance = anotherInstanceOrError.mustValue();

  const anotherJsonable = AasJsonization.toJsonable(anotherInstance);

  const inequalityError = TestCommon.checkJsonablesEqual(jsonable, anotherJsonable);
  if (inequalityError !== null) {
    throw new Error(
      "The minimal example of IHasDataSpecification " +
        "as an instance of BasicEventElement serialized " +
        "to JSON, then de-serialized and serialized again does not match " +
        `the first JSON: ${inequalityError.path}: ${inequalityError.message}`
    );
  }
});

test("IHasDataSpecification round-trip " + "starting from Blob OK", () => {
  const instance = TestCommonJsonization.loadMinimalBlob();

  const jsonable = AasJsonization.toJsonable(instance);

  const anotherInstanceOrError =
    AasJsonization.hasDataSpecificationFromJsonable(jsonable);
  expect(anotherInstanceOrError.error).toBeNull();
  const anotherInstance = anotherInstanceOrError.mustValue();

  const anotherJsonable = AasJsonization.toJsonable(anotherInstance);

  const inequalityError = TestCommon.checkJsonablesEqual(jsonable, anotherJsonable);
  if (inequalityError !== null) {
    throw new Error(
      "The minimal example of IHasDataSpecification " +
        "as an instance of Blob serialized " +
        "to JSON, then de-serialized and serialized again does not match " +
        `the first JSON: ${inequalityError.path}: ${inequalityError.message}`
    );
  }
});

test("IHasDataSpecification round-trip " + "starting from Capability OK", () => {
  const instance = TestCommonJsonization.loadMinimalCapability();

  const jsonable = AasJsonization.toJsonable(instance);

  const anotherInstanceOrError =
    AasJsonization.hasDataSpecificationFromJsonable(jsonable);
  expect(anotherInstanceOrError.error).toBeNull();
  const anotherInstance = anotherInstanceOrError.mustValue();

  const anotherJsonable = AasJsonization.toJsonable(anotherInstance);

  const inequalityError = TestCommon.checkJsonablesEqual(jsonable, anotherJsonable);
  if (inequalityError !== null) {
    throw new Error(
      "The minimal example of IHasDataSpecification " +
        "as an instance of Capability serialized " +
        "to JSON, then de-serialized and serialized again does not match " +
        `the first JSON: ${inequalityError.path}: ${inequalityError.message}`
    );
  }
});

test(
  "IHasDataSpecification round-trip " + "starting from ConceptDescription OK",
  () => {
    const instance = TestCommonJsonization.loadMinimalConceptDescription();

    const jsonable = AasJsonization.toJsonable(instance);

    const anotherInstanceOrError =
      AasJsonization.hasDataSpecificationFromJsonable(jsonable);
    expect(anotherInstanceOrError.error).toBeNull();
    const anotherInstance = anotherInstanceOrError.mustValue();

    const anotherJsonable = AasJsonization.toJsonable(anotherInstance);

    const inequalityError = TestCommon.checkJsonablesEqual(jsonable, anotherJsonable);
    if (inequalityError !== null) {
      throw new Error(
        "The minimal example of IHasDataSpecification " +
          "as an instance of ConceptDescription serialized " +
          "to JSON, then de-serialized and serialized again does not match " +
          `the first JSON: ${inequalityError.path}: ${inequalityError.message}`
      );
    }
  }
);

test("IHasDataSpecification round-trip " + "starting from Entity OK", () => {
  const instance = TestCommonJsonization.loadMinimalEntity();

  const jsonable = AasJsonization.toJsonable(instance);

  const anotherInstanceOrError =
    AasJsonization.hasDataSpecificationFromJsonable(jsonable);
  expect(anotherInstanceOrError.error).toBeNull();
  const anotherInstance = anotherInstanceOrError.mustValue();

  const anotherJsonable = AasJsonization.toJsonable(anotherInstance);

  const inequalityError = TestCommon.checkJsonablesEqual(jsonable, anotherJsonable);
  if (inequalityError !== null) {
    throw new Error(
      "The minimal example of IHasDataSpecification " +
        "as an instance of Entity serialized " +
        "to JSON, then de-serialized and serialized again does not match " +
        `the first JSON: ${inequalityError.path}: ${inequalityError.message}`
    );
  }
});

test("IHasDataSpecification round-trip " + "starting from File OK", () => {
  const instance = TestCommonJsonization.loadMinimalFile();

  const jsonable = AasJsonization.toJsonable(instance);

  const anotherInstanceOrError =
    AasJsonization.hasDataSpecificationFromJsonable(jsonable);
  expect(anotherInstanceOrError.error).toBeNull();
  const anotherInstance = anotherInstanceOrError.mustValue();

  const anotherJsonable = AasJsonization.toJsonable(anotherInstance);

  const inequalityError = TestCommon.checkJsonablesEqual(jsonable, anotherJsonable);
  if (inequalityError !== null) {
    throw new Error(
      "The minimal example of IHasDataSpecification " +
        "as an instance of File serialized " +
        "to JSON, then de-serialized and serialized again does not match " +
        `the first JSON: ${inequalityError.path}: ${inequalityError.message}`
    );
  }
});

test(
  "IHasDataSpecification round-trip " + "starting from MultiLanguageProperty OK",
  () => {
    const instance = TestCommonJsonization.loadMinimalMultiLanguageProperty();

    const jsonable = AasJsonization.toJsonable(instance);

    const anotherInstanceOrError =
      AasJsonization.hasDataSpecificationFromJsonable(jsonable);
    expect(anotherInstanceOrError.error).toBeNull();
    const anotherInstance = anotherInstanceOrError.mustValue();

    const anotherJsonable = AasJsonization.toJsonable(anotherInstance);

    const inequalityError = TestCommon.checkJsonablesEqual(jsonable, anotherJsonable);
    if (inequalityError !== null) {
      throw new Error(
        "The minimal example of IHasDataSpecification " +
          "as an instance of MultiLanguageProperty serialized " +
          "to JSON, then de-serialized and serialized again does not match " +
          `the first JSON: ${inequalityError.path}: ${inequalityError.message}`
      );
    }
  }
);

test("IHasDataSpecification round-trip " + "starting from Operation OK", () => {
  const instance = TestCommonJsonization.loadMinimalOperation();

  const jsonable = AasJsonization.toJsonable(instance);

  const anotherInstanceOrError =
    AasJsonization.hasDataSpecificationFromJsonable(jsonable);
  expect(anotherInstanceOrError.error).toBeNull();
  const anotherInstance = anotherInstanceOrError.mustValue();

  const anotherJsonable = AasJsonization.toJsonable(anotherInstance);

  const inequalityError = TestCommon.checkJsonablesEqual(jsonable, anotherJsonable);
  if (inequalityError !== null) {
    throw new Error(
      "The minimal example of IHasDataSpecification " +
        "as an instance of Operation serialized " +
        "to JSON, then de-serialized and serialized again does not match " +
        `the first JSON: ${inequalityError.path}: ${inequalityError.message}`
    );
  }
});

test("IHasDataSpecification round-trip " + "starting from Property OK", () => {
  const instance = TestCommonJsonization.loadMinimalProperty();

  const jsonable = AasJsonization.toJsonable(instance);

  const anotherInstanceOrError =
    AasJsonization.hasDataSpecificationFromJsonable(jsonable);
  expect(anotherInstanceOrError.error).toBeNull();
  const anotherInstance = anotherInstanceOrError.mustValue();

  const anotherJsonable = AasJsonization.toJsonable(anotherInstance);

  const inequalityError = TestCommon.checkJsonablesEqual(jsonable, anotherJsonable);
  if (inequalityError !== null) {
    throw new Error(
      "The minimal example of IHasDataSpecification " +
        "as an instance of Property serialized " +
        "to JSON, then de-serialized and serialized again does not match " +
        `the first JSON: ${inequalityError.path}: ${inequalityError.message}`
    );
  }
});

test("IHasDataSpecification round-trip " + "starting from Range OK", () => {
  const instance = TestCommonJsonization.loadMinimalRange();

  const jsonable = AasJsonization.toJsonable(instance);

  const anotherInstanceOrError =
    AasJsonization.hasDataSpecificationFromJsonable(jsonable);
  expect(anotherInstanceOrError.error).toBeNull();
  const anotherInstance = anotherInstanceOrError.mustValue();

  const anotherJsonable = AasJsonization.toJsonable(anotherInstance);

  const inequalityError = TestCommon.checkJsonablesEqual(jsonable, anotherJsonable);
  if (inequalityError !== null) {
    throw new Error(
      "The minimal example of IHasDataSpecification " +
        "as an instance of Range serialized " +
        "to JSON, then de-serialized and serialized again does not match " +
        `the first JSON: ${inequalityError.path}: ${inequalityError.message}`
    );
  }
});

test("IHasDataSpecification round-trip " + "starting from ReferenceElement OK", () => {
  const instance = TestCommonJsonization.loadMinimalReferenceElement();

  const jsonable = AasJsonization.toJsonable(instance);

  const anotherInstanceOrError =
    AasJsonization.hasDataSpecificationFromJsonable(jsonable);
  expect(anotherInstanceOrError.error).toBeNull();
  const anotherInstance = anotherInstanceOrError.mustValue();

  const anotherJsonable = AasJsonization.toJsonable(anotherInstance);

  const inequalityError = TestCommon.checkJsonablesEqual(jsonable, anotherJsonable);
  if (inequalityError !== null) {
    throw new Error(
      "The minimal example of IHasDataSpecification " +
        "as an instance of ReferenceElement serialized " +
        "to JSON, then de-serialized and serialized again does not match " +
        `the first JSON: ${inequalityError.path}: ${inequalityError.message}`
    );
  }
});

test("IHasDataSpecification round-trip " + "starting from Submodel OK", () => {
  const instance = TestCommonJsonization.loadMinimalSubmodel();

  const jsonable = AasJsonization.toJsonable(instance);

  const anotherInstanceOrError =
    AasJsonization.hasDataSpecificationFromJsonable(jsonable);
  expect(anotherInstanceOrError.error).toBeNull();
  const anotherInstance = anotherInstanceOrError.mustValue();

  const anotherJsonable = AasJsonization.toJsonable(anotherInstance);

  const inequalityError = TestCommon.checkJsonablesEqual(jsonable, anotherJsonable);
  if (inequalityError !== null) {
    throw new Error(
      "The minimal example of IHasDataSpecification " +
        "as an instance of Submodel serialized " +
        "to JSON, then de-serialized and serialized again does not match " +
        `the first JSON: ${inequalityError.path}: ${inequalityError.message}`
    );
  }
});

test(
  "IHasDataSpecification round-trip " + "starting from SubmodelElementCollection OK",
  () => {
    const instance = TestCommonJsonization.loadMinimalSubmodelElementCollection();

    const jsonable = AasJsonization.toJsonable(instance);

    const anotherInstanceOrError =
      AasJsonization.hasDataSpecificationFromJsonable(jsonable);
    expect(anotherInstanceOrError.error).toBeNull();
    const anotherInstance = anotherInstanceOrError.mustValue();

    const anotherJsonable = AasJsonization.toJsonable(anotherInstance);

    const inequalityError = TestCommon.checkJsonablesEqual(jsonable, anotherJsonable);
    if (inequalityError !== null) {
      throw new Error(
        "The minimal example of IHasDataSpecification " +
          "as an instance of SubmodelElementCollection serialized " +
          "to JSON, then de-serialized and serialized again does not match " +
          `the first JSON: ${inequalityError.path}: ${inequalityError.message}`
      );
    }
  }
);

test(
  "IHasDataSpecification round-trip " + "starting from SubmodelElementList OK",
  () => {
    const instance = TestCommonJsonization.loadMinimalSubmodelElementList();

    const jsonable = AasJsonization.toJsonable(instance);

    const anotherInstanceOrError =
      AasJsonization.hasDataSpecificationFromJsonable(jsonable);
    expect(anotherInstanceOrError.error).toBeNull();
    const anotherInstance = anotherInstanceOrError.mustValue();

    const anotherJsonable = AasJsonization.toJsonable(anotherInstance);

    const inequalityError = TestCommon.checkJsonablesEqual(jsonable, anotherJsonable);
    if (inequalityError !== null) {
      throw new Error(
        "The minimal example of IHasDataSpecification " +
          "as an instance of SubmodelElementList serialized " +
          "to JSON, then de-serialized and serialized again does not match " +
          `the first JSON: ${inequalityError.path}: ${inequalityError.message}`
      );
    }
  }
);

test("IHasDataSpecification deserialization fail", () => {
  const jsonable = "This is not a IHasDataSpecification.";

  const instanceOrError = AasJsonization.hasDataSpecificationFromJsonable(jsonable);
  expect(instanceOrError.error.message).toStrictEqual(
    "Expected a JSON object, but got: string"
  );
});

test("IQualifiable round-trip " + "starting from RelationshipElement OK", () => {
  const instance = TestCommonJsonization.loadMinimalRelationshipElement();

  const jsonable = AasJsonization.toJsonable(instance);

  const anotherInstanceOrError = AasJsonization.qualifiableFromJsonable(jsonable);
  expect(anotherInstanceOrError.error).toBeNull();
  const anotherInstance = anotherInstanceOrError.mustValue();

  const anotherJsonable = AasJsonization.toJsonable(anotherInstance);

  const inequalityError = TestCommon.checkJsonablesEqual(jsonable, anotherJsonable);
  if (inequalityError !== null) {
    throw new Error(
      "The minimal example of IQualifiable " +
        "as an instance of RelationshipElement serialized " +
        "to JSON, then de-serialized and serialized again does not match " +
        `the first JSON: ${inequalityError.path}: ${inequalityError.message}`
    );
  }
});

test(
  "IQualifiable round-trip " + "starting from AnnotatedRelationshipElement OK",
  () => {
    const instance = TestCommonJsonization.loadMinimalAnnotatedRelationshipElement();

    const jsonable = AasJsonization.toJsonable(instance);

    const anotherInstanceOrError = AasJsonization.qualifiableFromJsonable(jsonable);
    expect(anotherInstanceOrError.error).toBeNull();
    const anotherInstance = anotherInstanceOrError.mustValue();

    const anotherJsonable = AasJsonization.toJsonable(anotherInstance);

    const inequalityError = TestCommon.checkJsonablesEqual(jsonable, anotherJsonable);
    if (inequalityError !== null) {
      throw new Error(
        "The minimal example of IQualifiable " +
          "as an instance of AnnotatedRelationshipElement serialized " +
          "to JSON, then de-serialized and serialized again does not match " +
          `the first JSON: ${inequalityError.path}: ${inequalityError.message}`
      );
    }
  }
);

test("IQualifiable round-trip " + "starting from BasicEventElement OK", () => {
  const instance = TestCommonJsonization.loadMinimalBasicEventElement();

  const jsonable = AasJsonization.toJsonable(instance);

  const anotherInstanceOrError = AasJsonization.qualifiableFromJsonable(jsonable);
  expect(anotherInstanceOrError.error).toBeNull();
  const anotherInstance = anotherInstanceOrError.mustValue();

  const anotherJsonable = AasJsonization.toJsonable(anotherInstance);

  const inequalityError = TestCommon.checkJsonablesEqual(jsonable, anotherJsonable);
  if (inequalityError !== null) {
    throw new Error(
      "The minimal example of IQualifiable " +
        "as an instance of BasicEventElement serialized " +
        "to JSON, then de-serialized and serialized again does not match " +
        `the first JSON: ${inequalityError.path}: ${inequalityError.message}`
    );
  }
});

test("IQualifiable round-trip " + "starting from Blob OK", () => {
  const instance = TestCommonJsonization.loadMinimalBlob();

  const jsonable = AasJsonization.toJsonable(instance);

  const anotherInstanceOrError = AasJsonization.qualifiableFromJsonable(jsonable);
  expect(anotherInstanceOrError.error).toBeNull();
  const anotherInstance = anotherInstanceOrError.mustValue();

  const anotherJsonable = AasJsonization.toJsonable(anotherInstance);

  const inequalityError = TestCommon.checkJsonablesEqual(jsonable, anotherJsonable);
  if (inequalityError !== null) {
    throw new Error(
      "The minimal example of IQualifiable " +
        "as an instance of Blob serialized " +
        "to JSON, then de-serialized and serialized again does not match " +
        `the first JSON: ${inequalityError.path}: ${inequalityError.message}`
    );
  }
});

test("IQualifiable round-trip " + "starting from Capability OK", () => {
  const instance = TestCommonJsonization.loadMinimalCapability();

  const jsonable = AasJsonization.toJsonable(instance);

  const anotherInstanceOrError = AasJsonization.qualifiableFromJsonable(jsonable);
  expect(anotherInstanceOrError.error).toBeNull();
  const anotherInstance = anotherInstanceOrError.mustValue();

  const anotherJsonable = AasJsonization.toJsonable(anotherInstance);

  const inequalityError = TestCommon.checkJsonablesEqual(jsonable, anotherJsonable);
  if (inequalityError !== null) {
    throw new Error(
      "The minimal example of IQualifiable " +
        "as an instance of Capability serialized " +
        "to JSON, then de-serialized and serialized again does not match " +
        `the first JSON: ${inequalityError.path}: ${inequalityError.message}`
    );
  }
});

test("IQualifiable round-trip " + "starting from Entity OK", () => {
  const instance = TestCommonJsonization.loadMinimalEntity();

  const jsonable = AasJsonization.toJsonable(instance);

  const anotherInstanceOrError = AasJsonization.qualifiableFromJsonable(jsonable);
  expect(anotherInstanceOrError.error).toBeNull();
  const anotherInstance = anotherInstanceOrError.mustValue();

  const anotherJsonable = AasJsonization.toJsonable(anotherInstance);

  const inequalityError = TestCommon.checkJsonablesEqual(jsonable, anotherJsonable);
  if (inequalityError !== null) {
    throw new Error(
      "The minimal example of IQualifiable " +
        "as an instance of Entity serialized " +
        "to JSON, then de-serialized and serialized again does not match " +
        `the first JSON: ${inequalityError.path}: ${inequalityError.message}`
    );
  }
});

test("IQualifiable round-trip " + "starting from File OK", () => {
  const instance = TestCommonJsonization.loadMinimalFile();

  const jsonable = AasJsonization.toJsonable(instance);

  const anotherInstanceOrError = AasJsonization.qualifiableFromJsonable(jsonable);
  expect(anotherInstanceOrError.error).toBeNull();
  const anotherInstance = anotherInstanceOrError.mustValue();

  const anotherJsonable = AasJsonization.toJsonable(anotherInstance);

  const inequalityError = TestCommon.checkJsonablesEqual(jsonable, anotherJsonable);
  if (inequalityError !== null) {
    throw new Error(
      "The minimal example of IQualifiable " +
        "as an instance of File serialized " +
        "to JSON, then de-serialized and serialized again does not match " +
        `the first JSON: ${inequalityError.path}: ${inequalityError.message}`
    );
  }
});

test("IQualifiable round-trip " + "starting from MultiLanguageProperty OK", () => {
  const instance = TestCommonJsonization.loadMinimalMultiLanguageProperty();

  const jsonable = AasJsonization.toJsonable(instance);

  const anotherInstanceOrError = AasJsonization.qualifiableFromJsonable(jsonable);
  expect(anotherInstanceOrError.error).toBeNull();
  const anotherInstance = anotherInstanceOrError.mustValue();

  const anotherJsonable = AasJsonization.toJsonable(anotherInstance);

  const inequalityError = TestCommon.checkJsonablesEqual(jsonable, anotherJsonable);
  if (inequalityError !== null) {
    throw new Error(
      "The minimal example of IQualifiable " +
        "as an instance of MultiLanguageProperty serialized " +
        "to JSON, then de-serialized and serialized again does not match " +
        `the first JSON: ${inequalityError.path}: ${inequalityError.message}`
    );
  }
});

test("IQualifiable round-trip " + "starting from Operation OK", () => {
  const instance = TestCommonJsonization.loadMinimalOperation();

  const jsonable = AasJsonization.toJsonable(instance);

  const anotherInstanceOrError = AasJsonization.qualifiableFromJsonable(jsonable);
  expect(anotherInstanceOrError.error).toBeNull();
  const anotherInstance = anotherInstanceOrError.mustValue();

  const anotherJsonable = AasJsonization.toJsonable(anotherInstance);

  const inequalityError = TestCommon.checkJsonablesEqual(jsonable, anotherJsonable);
  if (inequalityError !== null) {
    throw new Error(
      "The minimal example of IQualifiable " +
        "as an instance of Operation serialized " +
        "to JSON, then de-serialized and serialized again does not match " +
        `the first JSON: ${inequalityError.path}: ${inequalityError.message}`
    );
  }
});

test("IQualifiable round-trip " + "starting from Property OK", () => {
  const instance = TestCommonJsonization.loadMinimalProperty();

  const jsonable = AasJsonization.toJsonable(instance);

  const anotherInstanceOrError = AasJsonization.qualifiableFromJsonable(jsonable);
  expect(anotherInstanceOrError.error).toBeNull();
  const anotherInstance = anotherInstanceOrError.mustValue();

  const anotherJsonable = AasJsonization.toJsonable(anotherInstance);

  const inequalityError = TestCommon.checkJsonablesEqual(jsonable, anotherJsonable);
  if (inequalityError !== null) {
    throw new Error(
      "The minimal example of IQualifiable " +
        "as an instance of Property serialized " +
        "to JSON, then de-serialized and serialized again does not match " +
        `the first JSON: ${inequalityError.path}: ${inequalityError.message}`
    );
  }
});

test("IQualifiable round-trip " + "starting from Range OK", () => {
  const instance = TestCommonJsonization.loadMinimalRange();

  const jsonable = AasJsonization.toJsonable(instance);

  const anotherInstanceOrError = AasJsonization.qualifiableFromJsonable(jsonable);
  expect(anotherInstanceOrError.error).toBeNull();
  const anotherInstance = anotherInstanceOrError.mustValue();

  const anotherJsonable = AasJsonization.toJsonable(anotherInstance);

  const inequalityError = TestCommon.checkJsonablesEqual(jsonable, anotherJsonable);
  if (inequalityError !== null) {
    throw new Error(
      "The minimal example of IQualifiable " +
        "as an instance of Range serialized " +
        "to JSON, then de-serialized and serialized again does not match " +
        `the first JSON: ${inequalityError.path}: ${inequalityError.message}`
    );
  }
});

test("IQualifiable round-trip " + "starting from ReferenceElement OK", () => {
  const instance = TestCommonJsonization.loadMinimalReferenceElement();

  const jsonable = AasJsonization.toJsonable(instance);

  const anotherInstanceOrError = AasJsonization.qualifiableFromJsonable(jsonable);
  expect(anotherInstanceOrError.error).toBeNull();
  const anotherInstance = anotherInstanceOrError.mustValue();

  const anotherJsonable = AasJsonization.toJsonable(anotherInstance);

  const inequalityError = TestCommon.checkJsonablesEqual(jsonable, anotherJsonable);
  if (inequalityError !== null) {
    throw new Error(
      "The minimal example of IQualifiable " +
        "as an instance of ReferenceElement serialized " +
        "to JSON, then de-serialized and serialized again does not match " +
        `the first JSON: ${inequalityError.path}: ${inequalityError.message}`
    );
  }
});

test("IQualifiable round-trip " + "starting from Submodel OK", () => {
  const instance = TestCommonJsonization.loadMinimalSubmodel();

  const jsonable = AasJsonization.toJsonable(instance);

  const anotherInstanceOrError = AasJsonization.qualifiableFromJsonable(jsonable);
  expect(anotherInstanceOrError.error).toBeNull();
  const anotherInstance = anotherInstanceOrError.mustValue();

  const anotherJsonable = AasJsonization.toJsonable(anotherInstance);

  const inequalityError = TestCommon.checkJsonablesEqual(jsonable, anotherJsonable);
  if (inequalityError !== null) {
    throw new Error(
      "The minimal example of IQualifiable " +
        "as an instance of Submodel serialized " +
        "to JSON, then de-serialized and serialized again does not match " +
        `the first JSON: ${inequalityError.path}: ${inequalityError.message}`
    );
  }
});

test("IQualifiable round-trip " + "starting from SubmodelElementCollection OK", () => {
  const instance = TestCommonJsonization.loadMinimalSubmodelElementCollection();

  const jsonable = AasJsonization.toJsonable(instance);

  const anotherInstanceOrError = AasJsonization.qualifiableFromJsonable(jsonable);
  expect(anotherInstanceOrError.error).toBeNull();
  const anotherInstance = anotherInstanceOrError.mustValue();

  const anotherJsonable = AasJsonization.toJsonable(anotherInstance);

  const inequalityError = TestCommon.checkJsonablesEqual(jsonable, anotherJsonable);
  if (inequalityError !== null) {
    throw new Error(
      "The minimal example of IQualifiable " +
        "as an instance of SubmodelElementCollection serialized " +
        "to JSON, then de-serialized and serialized again does not match " +
        `the first JSON: ${inequalityError.path}: ${inequalityError.message}`
    );
  }
});

test("IQualifiable round-trip " + "starting from SubmodelElementList OK", () => {
  const instance = TestCommonJsonization.loadMinimalSubmodelElementList();

  const jsonable = AasJsonization.toJsonable(instance);

  const anotherInstanceOrError = AasJsonization.qualifiableFromJsonable(jsonable);
  expect(anotherInstanceOrError.error).toBeNull();
  const anotherInstance = anotherInstanceOrError.mustValue();

  const anotherJsonable = AasJsonization.toJsonable(anotherInstance);

  const inequalityError = TestCommon.checkJsonablesEqual(jsonable, anotherJsonable);
  if (inequalityError !== null) {
    throw new Error(
      "The minimal example of IQualifiable " +
        "as an instance of SubmodelElementList serialized " +
        "to JSON, then de-serialized and serialized again does not match " +
        `the first JSON: ${inequalityError.path}: ${inequalityError.message}`
    );
  }
});

test("IQualifiable deserialization fail", () => {
  const jsonable = "This is not a IQualifiable.";

  const instanceOrError = AasJsonization.qualifiableFromJsonable(jsonable);
  expect(instanceOrError.error.message).toStrictEqual(
    "Expected a JSON object, but got: string"
  );
});

test("ISubmodelElement round-trip " + "starting from RelationshipElement OK", () => {
  const instance = TestCommonJsonization.loadMinimalRelationshipElement();

  const jsonable = AasJsonization.toJsonable(instance);

  const anotherInstanceOrError = AasJsonization.submodelElementFromJsonable(jsonable);
  expect(anotherInstanceOrError.error).toBeNull();
  const anotherInstance = anotherInstanceOrError.mustValue();

  const anotherJsonable = AasJsonization.toJsonable(anotherInstance);

  const inequalityError = TestCommon.checkJsonablesEqual(jsonable, anotherJsonable);
  if (inequalityError !== null) {
    throw new Error(
      "The minimal example of ISubmodelElement " +
        "as an instance of RelationshipElement serialized " +
        "to JSON, then de-serialized and serialized again does not match " +
        `the first JSON: ${inequalityError.path}: ${inequalityError.message}`
    );
  }
});

test(
  "ISubmodelElement round-trip " + "starting from AnnotatedRelationshipElement OK",
  () => {
    const instance = TestCommonJsonization.loadMinimalAnnotatedRelationshipElement();

    const jsonable = AasJsonization.toJsonable(instance);

    const anotherInstanceOrError = AasJsonization.submodelElementFromJsonable(jsonable);
    expect(anotherInstanceOrError.error).toBeNull();
    const anotherInstance = anotherInstanceOrError.mustValue();

    const anotherJsonable = AasJsonization.toJsonable(anotherInstance);

    const inequalityError = TestCommon.checkJsonablesEqual(jsonable, anotherJsonable);
    if (inequalityError !== null) {
      throw new Error(
        "The minimal example of ISubmodelElement " +
          "as an instance of AnnotatedRelationshipElement serialized " +
          "to JSON, then de-serialized and serialized again does not match " +
          `the first JSON: ${inequalityError.path}: ${inequalityError.message}`
      );
    }
  }
);

test("ISubmodelElement round-trip " + "starting from BasicEventElement OK", () => {
  const instance = TestCommonJsonization.loadMinimalBasicEventElement();

  const jsonable = AasJsonization.toJsonable(instance);

  const anotherInstanceOrError = AasJsonization.submodelElementFromJsonable(jsonable);
  expect(anotherInstanceOrError.error).toBeNull();
  const anotherInstance = anotherInstanceOrError.mustValue();

  const anotherJsonable = AasJsonization.toJsonable(anotherInstance);

  const inequalityError = TestCommon.checkJsonablesEqual(jsonable, anotherJsonable);
  if (inequalityError !== null) {
    throw new Error(
      "The minimal example of ISubmodelElement " +
        "as an instance of BasicEventElement serialized " +
        "to JSON, then de-serialized and serialized again does not match " +
        `the first JSON: ${inequalityError.path}: ${inequalityError.message}`
    );
  }
});

test("ISubmodelElement round-trip " + "starting from Blob OK", () => {
  const instance = TestCommonJsonization.loadMinimalBlob();

  const jsonable = AasJsonization.toJsonable(instance);

  const anotherInstanceOrError = AasJsonization.submodelElementFromJsonable(jsonable);
  expect(anotherInstanceOrError.error).toBeNull();
  const anotherInstance = anotherInstanceOrError.mustValue();

  const anotherJsonable = AasJsonization.toJsonable(anotherInstance);

  const inequalityError = TestCommon.checkJsonablesEqual(jsonable, anotherJsonable);
  if (inequalityError !== null) {
    throw new Error(
      "The minimal example of ISubmodelElement " +
        "as an instance of Blob serialized " +
        "to JSON, then de-serialized and serialized again does not match " +
        `the first JSON: ${inequalityError.path}: ${inequalityError.message}`
    );
  }
});

test("ISubmodelElement round-trip " + "starting from Capability OK", () => {
  const instance = TestCommonJsonization.loadMinimalCapability();

  const jsonable = AasJsonization.toJsonable(instance);

  const anotherInstanceOrError = AasJsonization.submodelElementFromJsonable(jsonable);
  expect(anotherInstanceOrError.error).toBeNull();
  const anotherInstance = anotherInstanceOrError.mustValue();

  const anotherJsonable = AasJsonization.toJsonable(anotherInstance);

  const inequalityError = TestCommon.checkJsonablesEqual(jsonable, anotherJsonable);
  if (inequalityError !== null) {
    throw new Error(
      "The minimal example of ISubmodelElement " +
        "as an instance of Capability serialized " +
        "to JSON, then de-serialized and serialized again does not match " +
        `the first JSON: ${inequalityError.path}: ${inequalityError.message}`
    );
  }
});

test("ISubmodelElement round-trip " + "starting from Entity OK", () => {
  const instance = TestCommonJsonization.loadMinimalEntity();

  const jsonable = AasJsonization.toJsonable(instance);

  const anotherInstanceOrError = AasJsonization.submodelElementFromJsonable(jsonable);
  expect(anotherInstanceOrError.error).toBeNull();
  const anotherInstance = anotherInstanceOrError.mustValue();

  const anotherJsonable = AasJsonization.toJsonable(anotherInstance);

  const inequalityError = TestCommon.checkJsonablesEqual(jsonable, anotherJsonable);
  if (inequalityError !== null) {
    throw new Error(
      "The minimal example of ISubmodelElement " +
        "as an instance of Entity serialized " +
        "to JSON, then de-serialized and serialized again does not match " +
        `the first JSON: ${inequalityError.path}: ${inequalityError.message}`
    );
  }
});

test("ISubmodelElement round-trip " + "starting from File OK", () => {
  const instance = TestCommonJsonization.loadMinimalFile();

  const jsonable = AasJsonization.toJsonable(instance);

  const anotherInstanceOrError = AasJsonization.submodelElementFromJsonable(jsonable);
  expect(anotherInstanceOrError.error).toBeNull();
  const anotherInstance = anotherInstanceOrError.mustValue();

  const anotherJsonable = AasJsonization.toJsonable(anotherInstance);

  const inequalityError = TestCommon.checkJsonablesEqual(jsonable, anotherJsonable);
  if (inequalityError !== null) {
    throw new Error(
      "The minimal example of ISubmodelElement " +
        "as an instance of File serialized " +
        "to JSON, then de-serialized and serialized again does not match " +
        `the first JSON: ${inequalityError.path}: ${inequalityError.message}`
    );
  }
});

test("ISubmodelElement round-trip " + "starting from MultiLanguageProperty OK", () => {
  const instance = TestCommonJsonization.loadMinimalMultiLanguageProperty();

  const jsonable = AasJsonization.toJsonable(instance);

  const anotherInstanceOrError = AasJsonization.submodelElementFromJsonable(jsonable);
  expect(anotherInstanceOrError.error).toBeNull();
  const anotherInstance = anotherInstanceOrError.mustValue();

  const anotherJsonable = AasJsonization.toJsonable(anotherInstance);

  const inequalityError = TestCommon.checkJsonablesEqual(jsonable, anotherJsonable);
  if (inequalityError !== null) {
    throw new Error(
      "The minimal example of ISubmodelElement " +
        "as an instance of MultiLanguageProperty serialized " +
        "to JSON, then de-serialized and serialized again does not match " +
        `the first JSON: ${inequalityError.path}: ${inequalityError.message}`
    );
  }
});

test("ISubmodelElement round-trip " + "starting from Operation OK", () => {
  const instance = TestCommonJsonization.loadMinimalOperation();

  const jsonable = AasJsonization.toJsonable(instance);

  const anotherInstanceOrError = AasJsonization.submodelElementFromJsonable(jsonable);
  expect(anotherInstanceOrError.error).toBeNull();
  const anotherInstance = anotherInstanceOrError.mustValue();

  const anotherJsonable = AasJsonization.toJsonable(anotherInstance);

  const inequalityError = TestCommon.checkJsonablesEqual(jsonable, anotherJsonable);
  if (inequalityError !== null) {
    throw new Error(
      "The minimal example of ISubmodelElement " +
        "as an instance of Operation serialized " +
        "to JSON, then de-serialized and serialized again does not match " +
        `the first JSON: ${inequalityError.path}: ${inequalityError.message}`
    );
  }
});

test("ISubmodelElement round-trip " + "starting from Property OK", () => {
  const instance = TestCommonJsonization.loadMinimalProperty();

  const jsonable = AasJsonization.toJsonable(instance);

  const anotherInstanceOrError = AasJsonization.submodelElementFromJsonable(jsonable);
  expect(anotherInstanceOrError.error).toBeNull();
  const anotherInstance = anotherInstanceOrError.mustValue();

  const anotherJsonable = AasJsonization.toJsonable(anotherInstance);

  const inequalityError = TestCommon.checkJsonablesEqual(jsonable, anotherJsonable);
  if (inequalityError !== null) {
    throw new Error(
      "The minimal example of ISubmodelElement " +
        "as an instance of Property serialized " +
        "to JSON, then de-serialized and serialized again does not match " +
        `the first JSON: ${inequalityError.path}: ${inequalityError.message}`
    );
  }
});

test("ISubmodelElement round-trip " + "starting from Range OK", () => {
  const instance = TestCommonJsonization.loadMinimalRange();

  const jsonable = AasJsonization.toJsonable(instance);

  const anotherInstanceOrError = AasJsonization.submodelElementFromJsonable(jsonable);
  expect(anotherInstanceOrError.error).toBeNull();
  const anotherInstance = anotherInstanceOrError.mustValue();

  const anotherJsonable = AasJsonization.toJsonable(anotherInstance);

  const inequalityError = TestCommon.checkJsonablesEqual(jsonable, anotherJsonable);
  if (inequalityError !== null) {
    throw new Error(
      "The minimal example of ISubmodelElement " +
        "as an instance of Range serialized " +
        "to JSON, then de-serialized and serialized again does not match " +
        `the first JSON: ${inequalityError.path}: ${inequalityError.message}`
    );
  }
});

test("ISubmodelElement round-trip " + "starting from ReferenceElement OK", () => {
  const instance = TestCommonJsonization.loadMinimalReferenceElement();

  const jsonable = AasJsonization.toJsonable(instance);

  const anotherInstanceOrError = AasJsonization.submodelElementFromJsonable(jsonable);
  expect(anotherInstanceOrError.error).toBeNull();
  const anotherInstance = anotherInstanceOrError.mustValue();

  const anotherJsonable = AasJsonization.toJsonable(anotherInstance);

  const inequalityError = TestCommon.checkJsonablesEqual(jsonable, anotherJsonable);
  if (inequalityError !== null) {
    throw new Error(
      "The minimal example of ISubmodelElement " +
        "as an instance of ReferenceElement serialized " +
        "to JSON, then de-serialized and serialized again does not match " +
        `the first JSON: ${inequalityError.path}: ${inequalityError.message}`
    );
  }
});

test(
  "ISubmodelElement round-trip " + "starting from SubmodelElementCollection OK",
  () => {
    const instance = TestCommonJsonization.loadMinimalSubmodelElementCollection();

    const jsonable = AasJsonization.toJsonable(instance);

    const anotherInstanceOrError = AasJsonization.submodelElementFromJsonable(jsonable);
    expect(anotherInstanceOrError.error).toBeNull();
    const anotherInstance = anotherInstanceOrError.mustValue();

    const anotherJsonable = AasJsonization.toJsonable(anotherInstance);

    const inequalityError = TestCommon.checkJsonablesEqual(jsonable, anotherJsonable);
    if (inequalityError !== null) {
      throw new Error(
        "The minimal example of ISubmodelElement " +
          "as an instance of SubmodelElementCollection serialized " +
          "to JSON, then de-serialized and serialized again does not match " +
          `the first JSON: ${inequalityError.path}: ${inequalityError.message}`
      );
    }
  }
);

test("ISubmodelElement round-trip " + "starting from SubmodelElementList OK", () => {
  const instance = TestCommonJsonization.loadMinimalSubmodelElementList();

  const jsonable = AasJsonization.toJsonable(instance);

  const anotherInstanceOrError = AasJsonization.submodelElementFromJsonable(jsonable);
  expect(anotherInstanceOrError.error).toBeNull();
  const anotherInstance = anotherInstanceOrError.mustValue();

  const anotherJsonable = AasJsonization.toJsonable(anotherInstance);

  const inequalityError = TestCommon.checkJsonablesEqual(jsonable, anotherJsonable);
  if (inequalityError !== null) {
    throw new Error(
      "The minimal example of ISubmodelElement " +
        "as an instance of SubmodelElementList serialized " +
        "to JSON, then de-serialized and serialized again does not match " +
        `the first JSON: ${inequalityError.path}: ${inequalityError.message}`
    );
  }
});

test("ISubmodelElement deserialization fail", () => {
  const jsonable = "This is not a ISubmodelElement.";

  const instanceOrError = AasJsonization.submodelElementFromJsonable(jsonable);
  expect(instanceOrError.error.message).toStrictEqual(
    "Expected a JSON object, but got: string"
  );
});

test(
  "IRelationshipElement round-trip " + "starting from AnnotatedRelationshipElement OK",
  () => {
    const instance = TestCommonJsonization.loadMinimalAnnotatedRelationshipElement();

    const jsonable = AasJsonization.toJsonable(instance);

    const anotherInstanceOrError =
      AasJsonization.relationshipElementFromJsonable(jsonable);
    expect(anotherInstanceOrError.error).toBeNull();
    const anotherInstance = anotherInstanceOrError.mustValue();

    const anotherJsonable = AasJsonization.toJsonable(anotherInstance);

    const inequalityError = TestCommon.checkJsonablesEqual(jsonable, anotherJsonable);
    if (inequalityError !== null) {
      throw new Error(
        "The minimal example of IRelationshipElement " +
          "as an instance of AnnotatedRelationshipElement serialized " +
          "to JSON, then de-serialized and serialized again does not match " +
          `the first JSON: ${inequalityError.path}: ${inequalityError.message}`
      );
    }
  }
);

test(
  "IRelationshipElement round-trip " + "starting from RelationshipElement OK",
  () => {
    const instance = TestCommonJsonization.loadMinimalRelationshipElement();

    const jsonable = AasJsonization.toJsonable(instance);

    const anotherInstanceOrError =
      AasJsonization.relationshipElementFromJsonable(jsonable);
    expect(anotherInstanceOrError.error).toBeNull();
    const anotherInstance = anotherInstanceOrError.mustValue();

    const anotherJsonable = AasJsonization.toJsonable(anotherInstance);

    const inequalityError = TestCommon.checkJsonablesEqual(jsonable, anotherJsonable);
    if (inequalityError !== null) {
      throw new Error(
        "The minimal example of IRelationshipElement " +
          "as an instance of RelationshipElement serialized " +
          "to JSON, then de-serialized and serialized again does not match " +
          `the first JSON: ${inequalityError.path}: ${inequalityError.message}`
      );
    }
  }
);

test("IRelationshipElement deserialization fail", () => {
  const jsonable = "This is not a IRelationshipElement.";

  const instanceOrError = AasJsonization.relationshipElementFromJsonable(jsonable);
  expect(instanceOrError.error.message).toStrictEqual(
    "Expected a JSON object, but got: string"
  );
});

test("IDataElement round-trip " + "starting from Blob OK", () => {
  const instance = TestCommonJsonization.loadMinimalBlob();

  const jsonable = AasJsonization.toJsonable(instance);

  const anotherInstanceOrError = AasJsonization.dataElementFromJsonable(jsonable);
  expect(anotherInstanceOrError.error).toBeNull();
  const anotherInstance = anotherInstanceOrError.mustValue();

  const anotherJsonable = AasJsonization.toJsonable(anotherInstance);

  const inequalityError = TestCommon.checkJsonablesEqual(jsonable, anotherJsonable);
  if (inequalityError !== null) {
    throw new Error(
      "The minimal example of IDataElement " +
        "as an instance of Blob serialized " +
        "to JSON, then de-serialized and serialized again does not match " +
        `the first JSON: ${inequalityError.path}: ${inequalityError.message}`
    );
  }
});

test("IDataElement round-trip " + "starting from File OK", () => {
  const instance = TestCommonJsonization.loadMinimalFile();

  const jsonable = AasJsonization.toJsonable(instance);

  const anotherInstanceOrError = AasJsonization.dataElementFromJsonable(jsonable);
  expect(anotherInstanceOrError.error).toBeNull();
  const anotherInstance = anotherInstanceOrError.mustValue();

  const anotherJsonable = AasJsonization.toJsonable(anotherInstance);

  const inequalityError = TestCommon.checkJsonablesEqual(jsonable, anotherJsonable);
  if (inequalityError !== null) {
    throw new Error(
      "The minimal example of IDataElement " +
        "as an instance of File serialized " +
        "to JSON, then de-serialized and serialized again does not match " +
        `the first JSON: ${inequalityError.path}: ${inequalityError.message}`
    );
  }
});

test("IDataElement round-trip " + "starting from MultiLanguageProperty OK", () => {
  const instance = TestCommonJsonization.loadMinimalMultiLanguageProperty();

  const jsonable = AasJsonization.toJsonable(instance);

  const anotherInstanceOrError = AasJsonization.dataElementFromJsonable(jsonable);
  expect(anotherInstanceOrError.error).toBeNull();
  const anotherInstance = anotherInstanceOrError.mustValue();

  const anotherJsonable = AasJsonization.toJsonable(anotherInstance);

  const inequalityError = TestCommon.checkJsonablesEqual(jsonable, anotherJsonable);
  if (inequalityError !== null) {
    throw new Error(
      "The minimal example of IDataElement " +
        "as an instance of MultiLanguageProperty serialized " +
        "to JSON, then de-serialized and serialized again does not match " +
        `the first JSON: ${inequalityError.path}: ${inequalityError.message}`
    );
  }
});

test("IDataElement round-trip " + "starting from Property OK", () => {
  const instance = TestCommonJsonization.loadMinimalProperty();

  const jsonable = AasJsonization.toJsonable(instance);

  const anotherInstanceOrError = AasJsonization.dataElementFromJsonable(jsonable);
  expect(anotherInstanceOrError.error).toBeNull();
  const anotherInstance = anotherInstanceOrError.mustValue();

  const anotherJsonable = AasJsonization.toJsonable(anotherInstance);

  const inequalityError = TestCommon.checkJsonablesEqual(jsonable, anotherJsonable);
  if (inequalityError !== null) {
    throw new Error(
      "The minimal example of IDataElement " +
        "as an instance of Property serialized " +
        "to JSON, then de-serialized and serialized again does not match " +
        `the first JSON: ${inequalityError.path}: ${inequalityError.message}`
    );
  }
});

test("IDataElement round-trip " + "starting from Range OK", () => {
  const instance = TestCommonJsonization.loadMinimalRange();

  const jsonable = AasJsonization.toJsonable(instance);

  const anotherInstanceOrError = AasJsonization.dataElementFromJsonable(jsonable);
  expect(anotherInstanceOrError.error).toBeNull();
  const anotherInstance = anotherInstanceOrError.mustValue();

  const anotherJsonable = AasJsonization.toJsonable(anotherInstance);

  const inequalityError = TestCommon.checkJsonablesEqual(jsonable, anotherJsonable);
  if (inequalityError !== null) {
    throw new Error(
      "The minimal example of IDataElement " +
        "as an instance of Range serialized " +
        "to JSON, then de-serialized and serialized again does not match " +
        `the first JSON: ${inequalityError.path}: ${inequalityError.message}`
    );
  }
});

test("IDataElement round-trip " + "starting from ReferenceElement OK", () => {
  const instance = TestCommonJsonization.loadMinimalReferenceElement();

  const jsonable = AasJsonization.toJsonable(instance);

  const anotherInstanceOrError = AasJsonization.dataElementFromJsonable(jsonable);
  expect(anotherInstanceOrError.error).toBeNull();
  const anotherInstance = anotherInstanceOrError.mustValue();

  const anotherJsonable = AasJsonization.toJsonable(anotherInstance);

  const inequalityError = TestCommon.checkJsonablesEqual(jsonable, anotherJsonable);
  if (inequalityError !== null) {
    throw new Error(
      "The minimal example of IDataElement " +
        "as an instance of ReferenceElement serialized " +
        "to JSON, then de-serialized and serialized again does not match " +
        `the first JSON: ${inequalityError.path}: ${inequalityError.message}`
    );
  }
});

test("IDataElement deserialization fail", () => {
  const jsonable = "This is not a IDataElement.";

  const instanceOrError = AasJsonization.dataElementFromJsonable(jsonable);
  expect(instanceOrError.error.message).toStrictEqual(
    "Expected a JSON object, but got: string"
  );
});

test("IEventElement round-trip " + "starting from BasicEventElement OK", () => {
  const instance = TestCommonJsonization.loadMinimalBasicEventElement();

  const jsonable = AasJsonization.toJsonable(instance);

  const anotherInstanceOrError = AasJsonization.eventElementFromJsonable(jsonable);
  expect(anotherInstanceOrError.error).toBeNull();
  const anotherInstance = anotherInstanceOrError.mustValue();

  const anotherJsonable = AasJsonization.toJsonable(anotherInstance);

  const inequalityError = TestCommon.checkJsonablesEqual(jsonable, anotherJsonable);
  if (inequalityError !== null) {
    throw new Error(
      "The minimal example of IEventElement " +
        "as an instance of BasicEventElement serialized " +
        "to JSON, then de-serialized and serialized again does not match " +
        `the first JSON: ${inequalityError.path}: ${inequalityError.message}`
    );
  }
});

test("IEventElement deserialization fail", () => {
  const jsonable = "This is not a IEventElement.";

  const instanceOrError = AasJsonization.eventElementFromJsonable(jsonable);
  expect(instanceOrError.error.message).toStrictEqual(
    "Expected a JSON object, but got: string"
  );
});

test(
  "IDataSpecificationContent round-trip " +
    "starting from DataSpecificationIec61360 OK",
  () => {
    const instance = TestCommonJsonization.loadMinimalDataSpecificationIec61360();

    const jsonable = AasJsonization.toJsonable(instance);

    const anotherInstanceOrError =
      AasJsonization.dataSpecificationContentFromJsonable(jsonable);
    expect(anotherInstanceOrError.error).toBeNull();
    const anotherInstance = anotherInstanceOrError.mustValue();

    const anotherJsonable = AasJsonization.toJsonable(anotherInstance);

    const inequalityError = TestCommon.checkJsonablesEqual(jsonable, anotherJsonable);
    if (inequalityError !== null) {
      throw new Error(
        "The minimal example of IDataSpecificationContent " +
          "as an instance of DataSpecificationIec61360 serialized " +
          "to JSON, then de-serialized and serialized again does not match " +
          `the first JSON: ${inequalityError.path}: ${inequalityError.message}`
      );
    }
  }
);

test(
  "IDataSpecificationContent round-trip " +
    "starting from DataSpecificationPhysicalUnit OK",
  () => {
    const instance = TestCommonJsonization.loadMinimalDataSpecificationPhysicalUnit();

    const jsonable = AasJsonization.toJsonable(instance);

    const anotherInstanceOrError =
      AasJsonization.dataSpecificationContentFromJsonable(jsonable);
    expect(anotherInstanceOrError.error).toBeNull();
    const anotherInstance = anotherInstanceOrError.mustValue();

    const anotherJsonable = AasJsonization.toJsonable(anotherInstance);

    const inequalityError = TestCommon.checkJsonablesEqual(jsonable, anotherJsonable);
    if (inequalityError !== null) {
      throw new Error(
        "The minimal example of IDataSpecificationContent " +
          "as an instance of DataSpecificationPhysicalUnit serialized " +
          "to JSON, then de-serialized and serialized again does not match " +
          `the first JSON: ${inequalityError.path}: ${inequalityError.message}`
      );
    }
  }
);

test("IDataSpecificationContent deserialization fail", () => {
  const jsonable = "This is not a IDataSpecificationContent.";

  const instanceOrError = AasJsonization.dataSpecificationContentFromJsonable(jsonable);
  expect(instanceOrError.error.message).toStrictEqual(
    "Expected a JSON object, but got: string"
  );
});

// This code has been automatically generated by:
// testgen/aas_core_3_0_rc2_typescript_testgen/generate_test_for_jsonization_of_interfaces.py
// Do NOT edit or append.
